diff --git a/CMakeLists.txt b/CMakeLists.txt
index fe82ffcdf..a4454cd8e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -115,7 +115,18 @@ if(ENABLE_COVERAGE)
 	add_custom_target_coverage(check-upgrade-activated-extended)
 endif()
 
+option(BUILD_BITCOIN_CHRONIK "Activate the Chronik indexer" OFF)
+option(BUILD_BITCOIN_CHRONIK_PLUGINS "Activate the plugin system for Chronik" OFF)
 add_subdirectory(src)
+if(BUILD_BITCOIN_CHRONIK)
+	add_subdirectory(../../../chronik chronik)
+
+	get_target_property(dirs server INCLUDE_DIRECTORIES)
+	foreach(dir ${dirs})
+		message(STATUS "include dir='${dir}'")
+	endforeach()
+endif()
+
 add_subdirectory(test)
 
 add_subdirectory(contrib)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index d1214e8aa..6b169ef95 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -596,6 +596,9 @@ add_library(server
 )
 
 target_include_directories(server PRIVATE leveldb/helpers/memenv)
+if(BUILD_BITCOIN_CHRONIK)
+	target_include_directories(server PRIVATE ../../../../chronik)
+endif()
 
 # This require libevent
 set(EVENT_MIN_VERSION 2.0.22)
diff --git a/src/chainparamsbase.cpp b/src/chainparamsbase.cpp
index b6175221e..bc46d298b 100644
--- a/src/chainparamsbase.cpp
+++ b/src/chainparamsbase.cpp
@@ -48,27 +48,27 @@ const CBaseChainParams &BaseParams() {
  */
 std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string &chain) {
     if (chain == CBaseChainParams::MAIN) {
-        return std::make_unique<CBaseChainParams>("", 8332, 8334);
+        return std::make_unique<CBaseChainParams>("", 8332, 8334, 8331);
     }
 
     if (chain == CBaseChainParams::TESTNET) {
-        return std::make_unique<CBaseChainParams>("testnet3", 18332, 18334);
+        return std::make_unique<CBaseChainParams>("testnet3", 18332, 18334, 18331);
     }
 
     if (chain == CBaseChainParams::TESTNET4) {
-        return std::make_unique<CBaseChainParams>("testnet4", 28332, 28334);
+        return std::make_unique<CBaseChainParams>("testnet4", 28332, 28334, 28331);
     }
 
     if (chain == CBaseChainParams::SCALENET) {
-        return std::make_unique<CBaseChainParams>("scalenet", 38332, 38334);
+        return std::make_unique<CBaseChainParams>("scalenet", 38332, 38334, 38331);
     }
 
     if (chain == CBaseChainParams::CHIPNET) {
-        return std::make_unique<CBaseChainParams>("chipnet", 48332, 48334);
+        return std::make_unique<CBaseChainParams>("chipnet", 48332, 48334, 48331);
     }
 
     if (chain == CBaseChainParams::REGTEST) {
-        return std::make_unique<CBaseChainParams>("regtest", 18443, 18445);
+        return std::make_unique<CBaseChainParams>("regtest", 18443, 18445, 18442);
     }
 
     throw std::runtime_error(
diff --git a/src/chainparamsbase.h b/src/chainparamsbase.h
index 3919325a4..dc9860366 100644
--- a/src/chainparamsbase.h
+++ b/src/chainparamsbase.h
@@ -27,14 +27,19 @@ public:
     const std::string &DataDir() const { return strDataDir; }
     uint16_t RPCPort() const { return m_rpc_port; }
     uint16_t OnionServiceTargetPort() const { return m_onion_service_target_port; }
+    uint16_t ChronikPort() const { return m_chronik_port; }
 
     CBaseChainParams() = delete;
-    CBaseChainParams(const std::string &data_dir, uint16_t  rpc_port, uint16_t onion_service_target_port)
-        : m_rpc_port(rpc_port), m_onion_service_target_port(onion_service_target_port), strDataDir(data_dir) {}
+    CBaseChainParams(const std::string &data_dir, uint16_t rpc_port,
+                     uint16_t onion_service_target_port, uint16_t chronik_port)
+        : m_rpc_port(rpc_port),
+          m_onion_service_target_port(onion_service_target_port),
+          m_chronik_port(chronik_port), strDataDir(data_dir) {}
 
 private:
     const uint16_t m_rpc_port;
     const uint16_t m_onion_service_target_port;
+    const uint16_t m_chronik_port;
     std::string strDataDir;
 };
 
diff --git a/src/config/CMakeLists.txt b/src/config/CMakeLists.txt
index 648a1a4e0..af6bac7f4 100644
--- a/src/config/CMakeLists.txt
+++ b/src/config/CMakeLists.txt
@@ -212,6 +212,11 @@ set(ENABLE_WALLET ${BUILD_BITCOIN_WALLET})
 # Activate ZeroMQ
 set(ENABLE_ZMQ ${BUILD_BITCOIN_ZMQ})
 
+# Activate Chronik indexer
+set(ENABLE_CHRONIK ${BUILD_BITCOIN_CHRONIK})
+# Activate Chronik indexer plugins
+set(ENABLE_CHRONIK_PLUGINS ${BUILD_BITCOIN_CHRONIK_PLUGINS})
+
 # Try to find libqrencode
 # Only used in the wallet GUI
 if(ENABLE_QRCODE AND BUILD_BITCOIN_WALLET AND BUILD_BITCOIN_QT)
diff --git a/src/config/bitcoin-config.h.cmake.in b/src/config/bitcoin-config.h.cmake.in
index b3dd71201..25f9dcd28 100644
--- a/src/config/bitcoin-config.h.cmake.in
+++ b/src/config/bitcoin-config.h.cmake.in
@@ -63,6 +63,9 @@
 #cmakedefine ENABLE_WALLET 1
 #cmakedefine ENABLE_ZMQ 1
 
+/* Define if the Chronik indexer should be compiled in. */
+#cmakedefine01 ENABLE_CHRONIK
+
 /* Define if QR support should be compiled in */
 #cmakedefine USE_QRCODE 1
 
diff --git a/src/init.cpp b/src/init.cpp
index 4f6936900..905e68bd0 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -65,6 +65,10 @@
 #include <walletinitinterface.h>
 #include <warnings.h>
 
+#if ENABLE_CHRONIK
+#include "chronik-cpp/chronik.h"
+#endif
+
 #if ENABLE_ZMQ
 #include <zmq/zmqnotificationinterface.h>
 #include <zmq/zmqrpc.h>
@@ -89,6 +93,7 @@
 static constexpr bool DEFAULT_PROXYRANDOMIZE = true;
 /** Default for -rest */
 static constexpr bool DEFAULT_REST_ENABLE = false;
+static constexpr bool DEFAULT_CHRONIK = false;
 
 // Dump addresses to banlist.dat every 15 minutes (900s)
 static constexpr int DUMP_BANS_INTERVAL = 60 * 15;
@@ -283,6 +288,12 @@ void Shutdown(NodeContext &node) {
     // generate CValidationInterface callbacks, flush them...
     GetMainSignals().FlushBackgroundCallbacks();
 
+#if ENABLE_CHRONIK
+    if (gArgs.GetBoolArg("-chronik", DEFAULT_CHRONIK)) {
+        chronik::Stop();
+    }
+#endif
+
     // Any future callbacks will be dropped. This should absolutely be safe - if
     // missing a callback results in an unrecoverable situation, unclean
     // shutdown would too. The only reason to do the above flushes is to let the
@@ -396,7 +407,9 @@ void SetupServerArgs() {
         // GUI args. These will be overwritten by SetupUIArgs for the GUI
         "-allowselfsignedrootcertificates", "-choosedatadir", "-lang=<lang>",
         "-min", "-resetguisettings", "-rootcertificates=<file>", "-splash",
-        "-uiplatform"};
+        "-uiplatform",
+        "-chronikallowpause",
+        "-chronikcors",};
 
     // Set all of the args and their help
     // When adding new options to the categories, please keep and ensure alphabetical ordering.
@@ -614,6 +627,61 @@ void SetupServerArgs() {
                            "getrawtransaction rpc call (default: %d)",
                            DEFAULT_TXINDEX),
                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
+#if ENABLE_CHRONIK
+    gArgs.AddArg(
+        "-chronik",
+        strprintf("Enable the Chronik indexer, which can be read via a "
+                  "dedicated HTTP/Protobuf interface (default: %d)",
+                  DEFAULT_CHRONIK),
+        ArgsManager::ALLOW_BOOL, OptionsCategory::CHRONIK);
+    gArgs.AddArg(
+        "-chronikbind=<addr>[:port]",
+        strprintf(
+            "Bind the Chronik indexer to the given address to listen for "
+            "HTTP/Protobuf connections to access the index. Unlike the "
+            "JSON-RPC, it's ok to have this publicly exposed on the internet. "
+            "This option can be specified multiple times (default: %s; default "
+            "port: %u, testnet: %u, regtest: %u)",
+            Join(chronik::DEFAULT_BINDS, ", "),
+            defaultBaseParams->ChronikPort(), testnetBaseParams->ChronikPort(),
+            regtestBaseParams->ChronikPort()),
+        ArgsManager::ALLOW_STRING | ArgsManager::NETWORK_ONLY,
+        OptionsCategory::CHRONIK);
+    gArgs.AddArg("-chroniktokenindex",
+                   "Enable token indexing in Chronik (default: 1)",
+                   ArgsManager::ALLOW_BOOL, OptionsCategory::CHRONIK);
+    gArgs.AddArg("-chroniklokadidindex",
+                   "Enable LOKAD ID indexing in Chronik (default: 1)",
+                   ArgsManager::ALLOW_BOOL, OptionsCategory::CHRONIK);
+    gArgs.AddArg("-chronikreindex",
+                   "Reindex the Chronik indexer from genesis, but leave the "
+                   "other indexes untouched",
+                   ArgsManager::ALLOW_BOOL, OptionsCategory::CHRONIK);
+    gArgs.AddArg(
+        "-chroniktxnumcachebuckets",
+        strprintf(
+            "Tuning param of the TxNumCache, specifies how many buckets "
+            "to use on the belt. Caution against setting this too high, "
+            "it may slow down indexing. Set to 0 to disable. (default: %d)",
+            chronik::DEFAULT_TX_NUM_CACHE_BUCKETS),
+        ArgsManager::ALLOW_INT, OptionsCategory::CHRONIK);
+    gArgs.AddArg(
+        "-chroniktxnumcachebucketsize",
+        strprintf(
+            "Tuning param of the TxNumCache, specifies the size of each bucket "
+            "on the belt. Unlike the number of buckets, this may be increased "
+            "without much danger of slowing the indexer down. The total cache "
+            "size will be `num_buckets * bucket_size * 40B`, so by default the "
+            "cache will require %dkB of memory. (default: %d)",
+            chronik::DEFAULT_TX_NUM_CACHE_BUCKETS *
+                chronik::DEFAULT_TX_NUM_CACHE_BUCKET_SIZE * 40 / 1000,
+            chronik::DEFAULT_TX_NUM_CACHE_BUCKET_SIZE),
+        ArgsManager::ALLOW_INT, OptionsCategory::CHRONIK);
+    gArgs.AddArg("-chronikperfstats",
+                   "Output some performance statistics (e.g. num cache hits, "
+                   "seconds spent) into a <datadir>/perf folder. (default: 0)",
+                   ArgsManager::ALLOW_BOOL, OptionsCategory::CHRONIK);
+#endif
     gArgs.AddArg(
         "-usecashaddr",
         strprintf("Use CashAddr address format for destination encoding "
@@ -1597,6 +1665,9 @@ bool AppInitParameterInteraction(Config &config) {
         if (gArgs.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {
             return InitError(_("Prune mode is incompatible with -txindex."));
         }
+        if (gArgs.GetBoolArg("-chronik", DEFAULT_CHRONIK)) {
+            return InitError(_("Prune mode is incompatible with -chronik."));
+        }
     }
 
     // -bind and -whitebind can't be set when not listening
@@ -2634,6 +2705,16 @@ bool AppInitMain(Config &config, RPCServer &rpcServer,
         g_txindex->Start();
     }
 
+#if ENABLE_CHRONIK
+    if (gArgs.GetBoolArg("-chronik", DEFAULT_CHRONIK)) {
+        const bool fReindexChronik =
+            fReindex || gArgs.GetBoolArg("-chronikreindex", false);
+        if (!chronik::Start(config, node, fReindexChronik)) {
+            return false;
+        }
+    }
+#endif
+
     // Step 9: load wallet
     for (const auto &client : node.chain_clients) {
         if (!client->load(chainparams)) {
diff --git a/src/logging.h b/src/logging.h
index ffc9ef69c..5eb180d9b 100644
--- a/src/logging.h
+++ b/src/logging.h
@@ -67,6 +67,8 @@ enum LogFlags : uint32_t {
     //! For the adjustable blocksize limit algorithm (consensu/abla.*)
     ABLA = (1 << 25),
 
+    CHRONIK = (1 << 26),
+
     ALL = ~uint32_t(0) & ~uint32_t(HTTPTRACE),
 };
 
diff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp
index bc058f40d..b35762c35 100644
--- a/src/node/blockstorage.cpp
+++ b/src/node/blockstorage.cpp
@@ -403,6 +403,44 @@ bool ReadBlockFromDisk(CBlock &block, const CBlockIndex *pindex,
     return true;
 }
 
+bool ReadTxFromDisk(CMutableTransaction &tx, const FlatFilePos &pos) {
+    // Open history file to read
+    CAutoFile filein(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);
+    if (filein.IsNull()) {
+        return error("ReadTxFromDisk: OpenBlockFile failed for %s",
+                     pos.ToString());
+    }
+
+    // Read tx
+    try {
+        filein >> tx;
+    } catch (const std::exception &e) {
+        return error("%s: Deserialize or I/O error - %s at %s", __func__,
+                     e.what(), pos.ToString());
+    }
+
+    return true;
+}
+
+bool ReadTxUndoFromDisk(CTxUndo &tx_undo, const FlatFilePos &pos) {
+    // Open undo file to read
+    CAutoFile filein(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);
+    if (filein.IsNull()) {
+        return error("ReadTxUndoFromDisk: OpenUndoFile failed for %s",
+                     pos.ToString());
+    }
+
+    // Read undo data
+    try {
+        filein >> tx_undo;
+    } catch (const std::exception &e) {
+        return error("%s: Deserialize or I/O error - %s at %s", __func__,
+                     e.what(), pos.ToString());
+    }
+
+    return true;
+}
+
 static std::optional<CAutoFile> ReadBlockSizeCommon(uint64_t &blockSizeOut, const CBlockIndex *pindex,
                                                     const CChainParams &chainParams,
                                                     FlatFilePos *blockPosOut = nullptr) {
diff --git a/src/node/blockstorage.h b/src/node/blockstorage.h
index 4da11e247..03e1960e8 100644
--- a/src/node/blockstorage.h
+++ b/src/node/blockstorage.h
@@ -15,6 +15,9 @@
 #include <set>
 #include <vector>
 
+class CTxUndo;
+class CMutableTransaction;
+
 class CBlock;
 class CBlockFileInfo;
 class CBlockIndex;
@@ -54,7 +57,7 @@ extern RecursiveMutex cs_LastBlockFile;
 extern std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_LastBlockFile);
 extern int nLastBlockFile GUARDED_BY(cs_LastBlockFile);
 extern bool fCheckForPruning GUARDED_BY(cs_LastBlockFile);
-extern std::set<const CBlockIndex*> setDirtyBlockIndex GUARDED_BY(cs_main);
+extern std::set<const CBlockIndex *> setDirtyBlockIndex GUARDED_BY(cs_main);
 extern std::set<int> setDirtyFileInfo GUARDED_BY(cs_LastBlockFile);
 
 //! Check whether the block associated with this index entry is pruned or not.
@@ -81,10 +84,8 @@ uint64_t CalculateCurrentUsage();
 void UnlinkPrunedFiles(const std::set<int> &setFilesToPrune);
 
 /** Functions for disk access for blocks */
-bool ReadBlockFromDisk(CBlock &block, const FlatFilePos &pos,
-                       const Consensus::Params &params);
-bool ReadBlockFromDisk(CBlock &block, const CBlockIndex *pindex,
-                       const Consensus::Params &params);
+bool ReadBlockFromDisk(CBlock &block, const FlatFilePos &pos, const Consensus::Params &params);
+bool ReadBlockFromDisk(CBlock &block, const CBlockIndex *pindex, const Consensus::Params &params);
 /**
  * Read raw block bytes from disk. Faster than the above, because this function just returns the raw block data without
  * any unserialization. Intended to be used by the net code for low-overhead serving of block data.
@@ -106,6 +107,11 @@ std::optional<uint64_t> ReadBlockSizeFromDisk(const CBlockIndex *pindex, const C
 bool UndoReadFromDisk(CBlockUndo &blockundo, const CBlockIndex *pindex);
 bool WriteUndoDataForBlock(const CBlockUndo &blockundo, CValidationState &state, CBlockIndex *pindex,
                            const CChainParams &chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+
+/** Functions for disk access for txs */
+bool ReadTxFromDisk(CMutableTransaction &tx, const FlatFilePos &pos);
+bool ReadTxUndoFromDisk(CTxUndo &tx, const FlatFilePos &pos);
+
 /**
  * Store block on disk. If dbp is non-nullptr, the file is known to already
  * reside on disk.
diff --git a/src/node/transaction.cpp b/src/node/transaction.cpp
index f5fbe5284..e83e4abcb 100644
--- a/src/node/transaction.cpp
+++ b/src/node/transaction.cpp
@@ -18,7 +18,7 @@
 #include <future>
 
 TxId BroadcastTransaction(const Config &config, const CTransactionRef tx,
-                          const bool allowhighfees) {
+                          const bool allowhighfees, const bool wait_callback) {
     std::promise<void> promise;
     const TxId &txid = tx->GetId();
 
@@ -27,6 +27,8 @@ TxId BroadcastTransaction(const Config &config, const CTransactionRef tx,
         nMaxRawTxFee = Amount::zero();
     }
 
+    bool callback_set = false;
+
     { // cs_main scope
         LOCK(cs_main);
         CCoinsViewCache &view = *pcoinsTip;
@@ -55,7 +57,9 @@ TxId BroadcastTransaction(const Config &config, const CTransactionRef tx,
 
                 throw JSONRPCError(RPC_TRANSACTION_ERROR,
                                    FormatStateMessage(state));
-            } else {
+            }
+
+            if (wait_callback) {
                 // If wallet is enabled, ensure that the wallet has been made
                 // aware of the new transaction prior to returning. This
                 // prevents a race where a user might call sendrawtransaction
@@ -64,6 +68,7 @@ TxId BroadcastTransaction(const Config &config, const CTransactionRef tx,
                 // have not yet been processed.
                 CallFunctionInValidationInterfaceQueue(
                     [&promise] { promise.set_value(); });
+                callback_set = true;
             }
         } else if (fHaveChain) {
             throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN,
@@ -75,7 +80,9 @@ TxId BroadcastTransaction(const Config &config, const CTransactionRef tx,
         }
     } // cs_main
 
-    promise.get_future().wait();
+    if (callback_set) {
+        promise.get_future().wait();
+    }
 
     if (!g_connman) {
         throw JSONRPCError(
diff --git a/src/node/transaction.h b/src/node/transaction.h
index 17866ff08..6417f4993 100644
--- a/src/node/transaction.h
+++ b/src/node/transaction.h
@@ -12,4 +12,5 @@ struct TxId;
 
 /** Broadcast a transaction */
 TxId BroadcastTransaction(const Config &config, CTransactionRef tx,
-                          bool allowhighfees = false);
+                          bool allowhighfees = false,
+                          bool wait_callback = true);
diff --git a/src/test/validation_block_tests.cpp b/src/test/validation_block_tests.cpp
index c37d6f4ea..1c89fd461 100644
--- a/src/test/validation_block_tests.cpp
+++ b/src/test/validation_block_tests.cpp
@@ -43,7 +43,7 @@ struct TestSubscriber : public CValidationInterface {
         m_expected_tip = block->GetHash();
     }
 
-    void BlockDisconnected(const std::shared_ptr<const CBlock> &block) override {
+    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex) override {
         BOOST_CHECK_EQUAL(m_expected_tip, block->GetHash());
 
         m_expected_tip = block->hashPrevBlock;
diff --git a/src/util/system.cpp b/src/util/system.cpp
index 8b4f39807..4bee86071 100644
--- a/src/util/system.cpp
+++ b/src/util/system.cpp
@@ -717,6 +717,9 @@ std::string ArgsManager::GetHelpMessage() const {
             case OptionsCategory::REGISTER_COMMANDS:
                 usage += HelpMessageGroup("Register Commands:");
                 break;
+            case OptionsCategory::CHRONIK:
+                usage += HelpMessageGroup("Chronik options:");
+                break;
             default:
                 break;
         }
diff --git a/src/util/system.h b/src/util/system.h
index c8a0a8bd1..a196294dd 100644
--- a/src/util/system.h
+++ b/src/util/system.h
@@ -127,6 +127,7 @@ enum class OptionsCategory {
     GUI,
     COMMANDS,
     REGISTER_COMMANDS,
+    CHRONIK,
 
     // Always the last option to avoid printing these in the help
     HIDDEN,
diff --git a/src/validation.cpp b/src/validation.cpp
index c803a411e..85038da9a 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -479,6 +479,20 @@ static bool CheckInputsFromMempoolAndCache(
     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata, nSigChecksOut);
 }
 
+// Get the coins spent by ptx from the coins_view. Assumes coins are present.
+static std::vector<Coin> getSpentCoins(const CTransactionRef &ptx,
+                                       const CCoinsViewCache &coins_view) {
+    std::vector<Coin> spent_coins;
+    spent_coins.reserve(ptx->vin.size());
+    for (const CTxIn &input : ptx->vin) {
+        Coin coin;
+        const bool coinFound = coins_view.GetCoin(input.prevout, coin);
+        assert(coinFound);
+        spent_coins.push_back(std::move(coin));
+    }
+    return spent_coins;
+}
+
 static bool
 AcceptToMemoryPoolWorker(const Config &config, CTxMemPool &pool,
                          CValidationState &state, const CTransactionRef &ptx,
@@ -796,10 +810,12 @@ AcceptToMemoryPoolWorker(const Config &config, CTxMemPool &pool,
             }
         }
 
+        GetMainSignals().TransactionAddedToMempool(
+            ptx,
+            std::make_shared<const std::vector<Coin>>(
+                getSpentCoins(ptx, view)));
     }
 
-    GetMainSignals().TransactionAddedToMempool(ptx);
-
     // Handle double spend proof orphans (if any)
     if (!rescuedDSPOrphans.empty()) {
         std::vector<NodeId> badProofNodeIds;
@@ -2262,7 +2278,7 @@ bool CChainState::DisconnectTip(const Config &config,
     UpdateTip(config, pindexDelete->pprev);
     // Let wallets know transactions went from 1-confirmed to
     // 0-confirmed or conflicted:
-    GetMainSignals().BlockDisconnected(pblock);
+    GetMainSignals().BlockDisconnected(pblock, pindexDelete);
     return true;
 }
 
diff --git a/src/validationinterface.cpp b/src/validationinterface.cpp
index d4e2c9c4c..e9adf802f 100644
--- a/src/validationinterface.cpp
+++ b/src/validationinterface.cpp
@@ -37,7 +37,7 @@ struct MainSignalsInstance {
     boost::signals2::signal<void(const CBlockIndex *, const CBlockIndex *,
                                  bool fInitialDownload)>
         UpdatedBlockTip;
-    boost::signals2::signal<void(const CTransactionRef &)>
+    boost::signals2::signal<void(const CTransactionRef &, std::shared_ptr<const std::vector<Coin>>)>
         TransactionAddedToMempool;
     boost::signals2::signal<void(const CTransactionRef &, const DspId &)>
         TransactionDoubleSpent;
@@ -47,7 +47,7 @@ struct MainSignalsInstance {
                                  const CBlockIndex *pindex,
                                  const std::vector<CTransactionRef> &)>
         BlockConnected;
-    boost::signals2::signal<void(const std::shared_ptr<const CBlock> &)>
+    boost::signals2::signal<void(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)>
         BlockDisconnected;
     boost::signals2::signal<void(const CTransactionRef &)>
         TransactionRemovedFromMempool;
@@ -140,14 +140,14 @@ void RegisterValidationInterface(CValidationInterface *pwalletIn) {
     conns.TransactionAddedToMempool =
         g_signals.m_internals->TransactionAddedToMempool.connect(
             std::bind(&CValidationInterface::TransactionAddedToMempool,
-                      pwalletIn, std::placeholders::_1));
+                      pwalletIn, std::placeholders::_1, std::placeholders::_2));
     conns.BlockConnected = g_signals.m_internals->BlockConnected.connect(
         std::bind(&CValidationInterface::BlockConnected, pwalletIn,
                   std::placeholders::_1, std::placeholders::_2,
                   std::placeholders::_3));
     conns.BlockDisconnected = g_signals.m_internals->BlockDisconnected.connect(
         std::bind(&CValidationInterface::BlockDisconnected, pwalletIn,
-                  std::placeholders::_1));
+                  std::placeholders::_1, std::placeholders::_2));
     conns.TransactionRemovedFromMempool =
         g_signals.m_internals->TransactionRemovedFromMempool.connect(
             std::bind(&CValidationInterface::TransactionRemovedFromMempool,
@@ -224,9 +224,9 @@ void CMainSignals::UpdatedBlockTip(const CBlockIndex *pindexNew,
     });
 }
 
-void CMainSignals::TransactionAddedToMempool(const CTransactionRef &ptx) {
+void CMainSignals::TransactionAddedToMempool(const CTransactionRef &ptx, std::shared_ptr<const std::vector<Coin>> spent_coins) {
     m_internals->m_schedulerClient.AddToProcessQueue(
-        [ptx, this] { m_internals->TransactionAddedToMempool(ptx); });
+        [ptx, spent_coins, this] { m_internals->TransactionAddedToMempool(ptx, spent_coins); });
 }
 
 void CMainSignals::TransactionDoubleSpent(const CTransactionRef &ptx, const DspId &dspId) {
@@ -249,9 +249,9 @@ void CMainSignals::BlockConnected(
 }
 
 void CMainSignals::BlockDisconnected(
-    const std::shared_ptr<const CBlock> &pblock) {
+    const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) {
     m_internals->m_schedulerClient.AddToProcessQueue(
-        [pblock, this] { m_internals->BlockDisconnected(pblock); });
+        [pblock, pindex, this] { m_internals->BlockDisconnected(pblock, pindex); });
 }
 
 void CMainSignals::ChainStateFlushed(const CBlockLocator &locator) {
diff --git a/src/validationinterface.h b/src/validationinterface.h
index c0e6e99f3..b36b3db2c 100644
--- a/src/validationinterface.h
+++ b/src/validationinterface.h
@@ -16,6 +16,7 @@
 #include <vector>
 
 extern RecursiveMutex cs_main;
+class Coin;
 class CBlock;
 class CBlockIndex;
 struct CBlockLocator;
@@ -106,15 +107,14 @@ protected:
      *
      * Called on a background thread.
      */
-    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew,
-                                 const CBlockIndex *pindexFork,
-                                 bool fInitialDownload) {}
+    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {}
     /**
      * Notifies listeners of a transaction having been added to mempool.
      *
      * Called on a background thread.
      */
-    virtual void TransactionAddedToMempool(const CTransactionRef &ptxn) {}
+    virtual void TransactionAddedToMempool(const CTransactionRef &ptxn,
+                                           std::shared_ptr<const std::vector<Coin>> spent_coins) {}
 
     /**
      * Notifies listeners of a new valid double-spend proof having been
@@ -152,17 +152,14 @@ protected:
      *
      * Called on a background thread.
      */
-    virtual void
-    BlockConnected(const std::shared_ptr<const CBlock> &block,
-                   const CBlockIndex *pindex,
-                   const std::vector<CTransactionRef> &txnConflicted) {}
+    virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex,
+                                const std::vector<CTransactionRef> &txnConflicted) {}
     /**
      * Notifies listeners of a block being disconnected
      *
      * Called on a background thread.
      */
-    virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block) {
-    }
+    virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex) {}
     /**
      * Notifies listeners of the new active block chain on-disk.
      *
@@ -181,8 +178,7 @@ protected:
      */
     virtual void ChainStateFlushed(const CBlockLocator &locator) {}
     /** Tells listeners to broadcast their data. */
-    virtual void ResendWalletTransactions(int64_t nBestBlockTime,
-                                          CConnman *connman) {}
+    virtual void ResendWalletTransactions(int64_t nBestBlockTime, CConnman *connman) {}
     /**
      * Notifies listeners of a block validation result.
      * If the provided CValidationState IsValid, the provided block
@@ -195,8 +191,7 @@ protected:
      * has been received and connected to the headers tree, though not validated
      * yet.
      */
-    virtual void NewPoWValidBlock(const CBlockIndex *pindex,
-                                  const std::shared_ptr<const CBlock> &block){};
+    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block){};
     friend void ::RegisterValidationInterface(CValidationInterface *);
     friend void ::UnregisterValidationInterface(CValidationInterface *);
     friend void ::UnregisterAllValidationInterfaces();
@@ -210,8 +205,7 @@ private:
     friend void ::RegisterValidationInterface(CValidationInterface *);
     friend void ::UnregisterValidationInterface(CValidationInterface *);
     friend void ::UnregisterAllValidationInterfaces();
-    friend void ::CallFunctionInValidationInterfaceQueue(
-        std::function<void()> func);
+    friend void ::CallFunctionInValidationInterfaceQueue(std::function<void()> func);
 
     void MempoolEntryRemoved(CTransactionRef tx, MemPoolRemovalReason reason);
 
@@ -236,21 +230,17 @@ public:
     /** Unregister with mempool */
     void UnregisterWithMempoolSignals(CTxMemPool &pool);
 
-    void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *,
-                         bool fInitialDownload);
-    void TransactionAddedToMempool(const CTransactionRef &);
+    void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *, bool fInitialDownload);
+    void TransactionAddedToMempool(const CTransactionRef &, std::shared_ptr<const std::vector<Coin>>);
     void TransactionDoubleSpent(const CTransactionRef &, const DspId &);
     void BadDSProofsDetectedFromNodeIds(const std::vector<NodeId> &);
-    void
-    BlockConnected(const std::shared_ptr<const CBlock> &,
-                   const CBlockIndex *pindex,
-                   const std::shared_ptr<const std::vector<CTransactionRef>> &);
-    void BlockDisconnected(const std::shared_ptr<const CBlock> &);
+    void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex,
+                        const std::shared_ptr<const std::vector<CTransactionRef>> &);
+    void BlockDisconnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *);
     void ChainStateFlushed(const CBlockLocator &);
     void Broadcast(int64_t nBestBlockTime, CConnman *connman);
     void BlockChecked(const CBlock &, const CValidationState &);
-    void NewPoWValidBlock(const CBlockIndex *,
-                          const std::shared_ptr<const CBlock> &);
+    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock> &);
 };
 
 CMainSignals &GetMainSignals();
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index dcc4c9d92..fef9b0698 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -1287,7 +1287,7 @@ void CWallet::SyncTransaction(const CTransactionRef &ptx,
     MarkInputsDirty(ptx);
 }
 
-void CWallet::TransactionAddedToMempool(const CTransactionRef &ptx) {
+void CWallet::TransactionAddedToMempool(const CTransactionRef &ptx, std::shared_ptr<const std::vector<Coin>> spent_coins) {
     auto locked_chain = chain().lock();
     LOCK(cs_wallet);
     SyncTransaction(ptx, BlockHash(), 0 /* position in block */);
@@ -1332,7 +1332,7 @@ void CWallet::BlockConnected(
     m_last_block_processed = pindex->GetBlockHash();
 }
 
-void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock> &pblock) {
+void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) {
     auto locked_chain = chain().lock();
     LOCK(cs_wallet);
 
diff --git a/src/wallet/wallet.h b/src/wallet/wallet.h
index e021297d7..9133229d4 100644
--- a/src/wallet/wallet.h
+++ b/src/wallet/wallet.h
@@ -1072,13 +1072,13 @@ public:
     bool AddToWallet(const CWalletTx &wtxIn, bool fFlushOnClose = true);
     void LoadToWallet(const CWalletTx &wtxIn)
         EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
-    void TransactionAddedToMempool(const CTransactionRef &tx) override;
+    void TransactionAddedToMempool(const CTransactionRef &tx, std::shared_ptr<const std::vector<Coin>>) override;
     void
     BlockConnected(const std::shared_ptr<const CBlock> &pblock,
                    const CBlockIndex *pindex,
                    const std::vector<CTransactionRef> &vtxConflicted) override;
     void
-    BlockDisconnected(const std::shared_ptr<const CBlock> &pblock) override;
+    BlockDisconnected(const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) override;
     void TransactionDoubleSpent(const CTransactionRef &ptxn,
                                 const DspId &dspId) override;
     int64_t RescanFromTime(int64_t startTime,
diff --git a/src/zmq/zmqnotificationinterface.cpp b/src/zmq/zmqnotificationinterface.cpp
index 97d9f13e1..8c7dda676 100644
--- a/src/zmq/zmqnotificationinterface.cpp
+++ b/src/zmq/zmqnotificationinterface.cpp
@@ -146,7 +146,7 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew,
 }
 
 void CZMQNotificationInterface::TransactionAddedToMempool(
-    const CTransactionRef &ptx) {
+    const CTransactionRef &ptx, std::shared_ptr<const std::vector<Coin>>) {
     // Used by BlockConnected and BlockDisconnected as well, because they're all
     // the same external callback.
     const CTransaction &tx = *ptx;
@@ -162,16 +162,16 @@ void CZMQNotificationInterface::BlockConnected(
     const std::vector<CTransactionRef> &) {
     for (const CTransactionRef &ptx : pblock->vtx) {
         // Do a normal notify for each transaction added in the block
-        TransactionAddedToMempool(ptx);
+        TransactionAddedToMempool(ptx, {});
     }
 }
 
 void CZMQNotificationInterface::BlockDisconnected(
-    const std::shared_ptr<const CBlock> &pblock) {
+    const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) {
     for (const CTransactionRef &ptx : pblock->vtx) {
         // Do a normal notify for each transaction removed in block
         // disconnection
-        TransactionAddedToMempool(ptx);
+        TransactionAddedToMempool(ptx, {});
     }
 }
 
diff --git a/src/zmq/zmqnotificationinterface.h b/src/zmq/zmqnotificationinterface.h
index c1b21f150..ed68ad02c 100644
--- a/src/zmq/zmqnotificationinterface.h
+++ b/src/zmq/zmqnotificationinterface.h
@@ -27,11 +27,11 @@ protected:
     void Shutdown();
 
     // CValidationInterface
-    void TransactionAddedToMempool(const CTransactionRef &tx) override;
+    void TransactionAddedToMempool(const CTransactionRef &tx, std::shared_ptr<const std::vector<Coin>>) override;
     void BlockConnected(const std::shared_ptr<const CBlock> &pblock,
                         const CBlockIndex *pindexConnected,
                         const std::vector<CTransactionRef> &vtxConflicted) override;
-    void BlockDisconnected(const std::shared_ptr<const CBlock> &pblock) override;
+    void BlockDisconnected(const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) override;
     void UpdatedBlockTip(const CBlockIndex *pindexNew,
                          const CBlockIndex *pindexFork,
                          bool fInitialDownload) override;
diff --git a/test/config.ini.cmake.in b/test/config.ini.cmake.in
index 6d5a6e3b6..bf67ca41e 100644
--- a/test/config.ini.cmake.in
+++ b/test/config.ini.cmake.in
@@ -20,4 +20,6 @@ ENABLE_WALLET=${BUILD_BITCOIN_WALLET}
 ENABLE_CLI=${BUILD_BITCOIN_CLI}
 ENABLE_BITCOIND=ON
 ENABLE_FUZZ=${ENABLE_FUZZ}
+ENABLE_CHRONIK=${BUILD_BITCOIN_CHRONIK}
+ENABLE_CHRONIK_PLUGINS=${BUILD_BITCOIN_CHRONIK_PLUGINS}
 ENABLE_ZMQ=${BUILD_BITCOIN_ZMQ}
diff --git a/test/functional/chronik_avalanche.py b/test/functional/chronik_avalanche.py
new file mode 100644
index 000000000..038fd3e47
--- /dev/null
+++ b/test/functional/chronik_avalanche.py
@@ -0,0 +1,152 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test whether Chronik indexes the avalanche state correctly."""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.avatools import can_find_inv_in_poll, get_ava_p2p_interface
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.script import OP_RETURN, CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+QUORUM_NODE_COUNT = 16
+
+
+class ChronikAvalancheTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [
+            [
+                "-avaproofstakeutxodustthreshold=1000000",
+                "-avaproofstakeutxoconfirmations=1",
+                "-avacooldown=0",
+                "-avaminquorumstake=0",
+                "-avaminavaproofsnodecount=0",
+                "-chronik",
+                "-whitelist=noban@127.0.0.1",
+                "-persistavapeers=0",
+            ],
+        ]
+        self.supports_cli = False
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        # Build a fake quorum of nodes.
+        def get_quorum():
+            return [
+                get_ava_p2p_interface(self, node) for _ in range(0, QUORUM_NODE_COUNT)
+            ]
+
+        def has_finalized_tip(tip_expected):
+            hash_tip_final = int(tip_expected, 16)
+            can_find_inv_in_poll(quorum, hash_tip_final)
+            return node.isfinalblock(tip_expected)
+
+        # Generate us a coin
+        coinblockhash = self.generatetoaddress(
+            node, 1, ADDRESS_ECREG_P2SH_OP_TRUE, sync_fun=self.no_op
+        )[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        # Mature coin
+        self.generatetoaddress(
+            node, 100, ADDRESS_ECREG_UNSPENDABLE, sync_fun=self.no_op
+        )
+
+        # Pick one node from the quorum for polling.
+        quorum = get_quorum()
+
+        assert node.getavalancheinfo()["ready_to_poll"] is True
+
+        # Build tx to finalize in a block
+        coinvalue = 5000000000
+        tx = CTransaction()
+        tx.nVersion = 2
+        tx.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(cointx, 16), 0),
+                scriptSig=SCRIPTSIG_OP_TRUE,
+                nSequence=0xFFFFFFFF,
+            )
+        ]
+        tx.vout = [
+            CTxOut(
+                nValue=coinvalue - 10000, scriptPubKey=CScript([OP_RETURN, bytes(100)])
+            )
+        ]
+
+        # Add to mempool
+        txid = node.sendrawtransaction(tx.serialize().hex())
+
+        # Tx not finalized
+        assert_equal(chronik.tx(txid).ok().block.is_final, False)
+
+        # Mine block
+        tip = self.generate(node, 1, sync_fun=self.no_op)[-1]
+
+        # Not finalized yet
+        assert_equal(chronik.block(tip).ok().block_info.is_final, False)
+        assert_equal(chronik.tx(txid).ok().block.is_final, False)
+
+        def chronik_wait_for_block_final(block_hash):
+            self.wait_until(lambda: chronik.block(tip).ok().block_info.is_final)
+
+        def chronik_wait_for_tx_final(txid):
+            self.wait_until(lambda: chronik.tx(txid).ok().block.is_final)
+
+        # After we wait, both block and tx are finalized
+        self.wait_until(lambda: has_finalized_tip(tip))
+        chronik_wait_for_block_final(tip)
+        chronik_wait_for_tx_final(txid)
+
+        # Restarting "wipes" the finalization status of blocks...
+        self.restart_node(0, self.extra_args[0] + ["-chronikreindex"])
+        assert_equal(chronik.block(tip).ok().block_info.is_final, False)
+        assert_equal(chronik.tx(txid).ok().block.is_final, False)
+
+        # ...so we establish a new quorum and poll again
+        quorum = get_quorum()
+        self.wait_until(lambda: has_finalized_tip(tip))
+        chronik_wait_for_block_final(tip)
+        chronik_wait_for_tx_final(txid)
+
+        # Generate 10 blocks to invalidate, wait for Avalanche
+        new_block_hashes = self.generate(node, 10, sync_fun=self.no_op)
+        self.wait_until(lambda: has_finalized_tip(new_block_hashes[-1]))
+        for block_hash in new_block_hashes:
+            chronik_wait_for_block_final(block_hash)
+
+        # After invalidation, blocks not found
+        node.invalidateblock(new_block_hashes[0])
+        node.syncwithvalidationinterfacequeue()
+        for block_hash in new_block_hashes:
+            chronik.block(block_hash).err(404)
+
+        # After reconsidering, blocks are not final again
+        node.reconsiderblock(new_block_hashes[-1])
+        node.syncwithvalidationinterfacequeue()
+        for block_hash in new_block_hashes:
+            assert_equal(chronik.block(block_hash).ok().block_info.is_final, False)
+
+        # Have to mine another block until avalanche considers reconsidering
+        self.generate(node, 1, sync_fun=self.no_op)
+        self.wait_until(lambda: has_finalized_tip(new_block_hashes[-1]))
+        for block_hash in new_block_hashes:
+            chronik_wait_for_block_final(block_hash)
+
+
+if __name__ == "__main__":
+    ChronikAvalancheTest().main()
diff --git a/test/functional/chronik_block.py b/test/functional/chronik_block.py
new file mode 100644
index 000000000..9f233e713
--- /dev/null
+++ b/test/functional/chronik_block.py
@@ -0,0 +1,151 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /block endpoint.
+"""
+
+from test_framework.address import ADDRESS_ECREG_P2SH_OP_TRUE, ADDRESS_ECREG_UNSPENDABLE
+from test_framework.blocktools import GENESIS_BLOCK_HASH, TIME_GENESIS_BLOCK
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikBlockTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        from test_framework.chronik.client import pb
+
+        expected_genesis_block = pb.Block(
+            block_info=pb.BlockInfo(
+                hash=bytes.fromhex(GENESIS_BLOCK_HASH)[::-1],
+                prev_hash=bytes(32),
+                height=0,
+                n_bits=0x207FFFFF,
+                timestamp=TIME_GENESIS_BLOCK,
+                block_size=285,
+                num_txs=1,
+                num_inputs=1,
+                num_outputs=1,
+                sum_input_sats=0,
+                sum_coinbase_output_sats=5000000000,
+                sum_normal_output_sats=0,
+                sum_burned_sats=0,
+            ),
+        )
+
+        # Not a valid hash or height
+        assert_equal(
+            chronik.block("1234f").err(400).msg, "400: Not a hash or height: 1234f"
+        )
+        assert_equal(
+            chronik.block("00" * 31).err(400).msg,
+            f'400: Not a hash or height: {"00"*31}',
+        )
+        assert_equal(chronik.block("01").err(400).msg, "400: Not a hash or height: 01")
+        assert_equal(
+            chronik.block("12345678901").err(400).msg,
+            "400: Not a hash or height: 12345678901",
+        )
+
+        # Query genesis block using height
+        assert_equal(chronik.block(0).ok(), expected_genesis_block)
+        # Or hash
+        assert_equal(chronik.block(GENESIS_BLOCK_HASH).ok(), expected_genesis_block)
+
+        # Block 1 not found
+        assert_equal(chronik.block(1).err(404).msg, "404: Block not found: 1")
+        # Block "0000...0000" not found
+        assert_equal(
+            chronik.block("00" * 32).err(404).msg, f'404: Block not found: {"00"*32}'
+        )
+
+        # Generate 100 blocks, verify they form a chain
+        block_hashes = [GENESIS_BLOCK_HASH] + self.generatetoaddress(
+            node, 100, ADDRESS_ECREG_P2SH_OP_TRUE
+        )
+
+        expected_proto_blocks = []
+        for i in range(1, 101):
+            proto_block = chronik.block(i).ok()
+            expected_proto = pb.Block(
+                block_info=pb.BlockInfo(
+                    hash=bytes.fromhex(block_hashes[i])[::-1],
+                    prev_hash=bytes.fromhex(block_hashes[i - 1])[::-1],
+                    height=i,
+                    n_bits=0x207FFFFF,
+                    timestamp=proto_block.block_info.timestamp,
+                    block_size=proto_block.block_info.block_size,
+                    num_txs=1,
+                    num_inputs=1,
+                    num_outputs=1,
+                    sum_input_sats=0,
+                    sum_coinbase_output_sats=5000000000,
+                    sum_normal_output_sats=0,
+                    sum_burned_sats=0,
+                ),
+            )
+            expected_proto_blocks.append(expected_proto)
+            assert_equal(proto_block, expected_proto)
+            assert_equal(proto_block, chronik.block(block_hashes[i]).ok())
+            block_hashes.append(proto_block.block_info.hash)
+
+        # Using -chronikreindex results in the same data
+        self.restart_node(0, ["-chronik", "-chronikreindex"])
+        for i in range(1, 101):
+            assert_equal(chronik.block(i).ok(), expected_proto_blocks[i - 1])
+
+        # Invalidate in the middle of the chain
+        node.invalidateblock(block_hashes[50])
+        # Gives 404 for the invalidated blocks
+        for i in range(50, 101):
+            assert_equal(chronik.block(i).err(404).msg, f"404: Block not found: {i}")
+            assert_equal(
+                chronik.block(block_hashes[i]).err(404).msg,
+                f"404: Block not found: {block_hashes[i]}",
+            )
+        # Previous blocks are still fine
+        for i in range(0, 50):
+            chronik.block(i).ok()
+            chronik.block(block_hashes[i]).ok()
+
+        # Mine fork block and check it connects
+        fork_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+
+        proto_block = chronik.block(50).ok()
+        assert_equal(
+            proto_block,
+            pb.Block(
+                block_info=pb.BlockInfo(
+                    hash=bytes.fromhex(fork_hash)[::-1],
+                    prev_hash=bytes.fromhex(block_hashes[49])[::-1],
+                    height=50,
+                    n_bits=0x207FFFFF,
+                    timestamp=proto_block.block_info.timestamp,
+                    block_size=proto_block.block_info.block_size,
+                    num_txs=1,
+                    num_inputs=1,
+                    num_outputs=1,
+                    sum_input_sats=0,
+                    sum_coinbase_output_sats=5000000000,
+                    sum_normal_output_sats=0,
+                    sum_burned_sats=0,
+                ),
+            ),
+        )
+        assert_equal(chronik.block(fork_hash).ok(), proto_block)
+
+
+if __name__ == "__main__":
+    ChronikBlockTest().main()
diff --git a/test/functional/chronik_block_info.py b/test/functional/chronik_block_info.py
new file mode 100644
index 000000000..7262f8d33
--- /dev/null
+++ b/test/functional/chronik_block_info.py
@@ -0,0 +1,134 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test if the `BlockInfo` fields are set correctly in Chronik.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_RETURN, CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikBlockInfoTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        node.setmocktime(1300000000)
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        prev_hash = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)[-1]
+
+        coinvalue = 5000000000
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(outpoint=COutPoint(int(cointx, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx.vout = [
+            CTxOut(coinvalue - 10000, P2SH_OP_TRUE),
+            CTxOut(1000, CScript([OP_RETURN, b"test"])),
+        ]
+        tx.rehash()
+
+        txid = node.sendrawtransaction(tx.serialize().hex())
+
+        tip_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[-1]
+
+        from test_framework.chronik.client import pb
+
+        proto_block = chronik.block(tip_hash).ok()
+        assert_equal(
+            proto_block,
+            pb.Block(
+                block_info=pb.BlockInfo(
+                    hash=bytes.fromhex(tip_hash)[::-1],
+                    prev_hash=bytes.fromhex(prev_hash)[::-1],
+                    height=102,
+                    n_bits=0x207FFFFF,
+                    timestamp=1300000018,
+                    block_size=proto_block.block_info.block_size,
+                    num_txs=2,
+                    num_inputs=2,
+                    num_outputs=3,
+                    sum_input_sats=coinvalue,
+                    sum_coinbase_output_sats=coinvalue + 9000,
+                    sum_normal_output_sats=coinvalue - 9000,
+                    sum_burned_sats=1000,
+                ),
+            ),
+        )
+
+        node.invalidateblock(tip_hash)
+        chronik.block(tip_hash).err(404)
+
+        tx2 = CTransaction()
+        tx2.vin = [
+            CTxIn(outpoint=COutPoint(int(txid, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx2.vout = [
+            CTxOut(3000, CScript([OP_RETURN, b"test"])),
+            CTxOut(5000, CScript([OP_RETURN, b"test"])),
+            CTxOut(coinvalue - 20000, P2SH_OP_TRUE),
+        ]
+        tx2.rehash()
+
+        block = create_block(
+            int(prev_hash, 16), create_coinbase(102, b"\x03" * 33), 1300000500
+        )
+        block.vtx += [tx, tx2]
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        assert_equal(
+            chronik.block(block.hash).ok(),
+            pb.Block(
+                block_info=pb.BlockInfo(
+                    hash=bytes.fromhex(block.hash)[::-1],
+                    prev_hash=bytes.fromhex(prev_hash)[::-1],
+                    height=102,
+                    n_bits=0x207FFFFF,
+                    timestamp=1300000500,
+                    block_size=403,
+                    num_txs=3,
+                    num_inputs=3,
+                    num_outputs=7,
+                    sum_input_sats=coinvalue * 2 - 10000,
+                    sum_coinbase_output_sats=coinvalue,
+                    sum_normal_output_sats=coinvalue * 2 - 21000,
+                    sum_burned_sats=9000,
+                ),
+            ),
+        )
+
+
+if __name__ == "__main__":
+    ChronikBlockInfoTest().main()
diff --git a/test/functional/chronik_block_txs.py b/test/functional/chronik_block_txs.py
new file mode 100644
index 000000000..06a0a867f
--- /dev/null
+++ b/test/functional/chronik_block_txs.py
@@ -0,0 +1,267 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /block-txs/:hash_or_height endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    GENESIS_BLOCK_HASH,
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_RETURN, CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikBlockTxsTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        node.setmocktime(1300000000)
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        # Not a valid hash or height
+        assert_equal(
+            chronik.block_txs("1234f").err(400).msg, "400: Not a hash or height: 1234f"
+        )
+        assert_equal(
+            chronik.block_txs("00" * 31).err(400).msg,
+            f'400: Not a hash or height: {"00"*31}',
+        )
+        assert_equal(
+            chronik.block_txs("01").err(400).msg, "400: Not a hash or height: 01"
+        )
+        assert_equal(
+            chronik.block_txs("12345678901").err(400).msg,
+            "400: Not a hash or height: 12345678901",
+        )
+
+        assert_equal(
+            chronik.block_txs("00" * 32, page=0, page_size=201).err(400).msg,
+            "400: Requested block tx page size 201 is too big, maximum is 200",
+        )
+        assert_equal(
+            chronik.block_txs("00" * 32, page=0, page_size=0).err(400).msg,
+            "400: Requested block tx page size 0 is too small, minimum is 1",
+        )
+        assert_equal(
+            chronik.block_txs("00" * 32, page=0, page_size=2**32).err(400).msg,
+            "400: Invalid param page_size: 4294967296, "
+            + "number too large to fit in target type",
+        )
+        assert_equal(
+            chronik.block_txs("00" * 32, page=2**32, page_size=1).err(400).msg,
+            "400: Invalid param page: 4294967296, "
+            + "number too large to fit in target type",
+        )
+
+        from test_framework.chronik.client import pb
+
+        assert_equal(
+            chronik.block_txs(GENESIS_BLOCK_HASH, page=2**32 - 1, page_size=200).ok(),
+            pb.TxHistoryPage(txs=[], num_pages=1, num_txs=1),
+        )
+
+        from test_framework.chronik.test_data import genesis_cb_tx
+
+        assert_equal(
+            chronik.block_txs(GENESIS_BLOCK_HASH).ok(),
+            pb.TxHistoryPage(
+                txs=[genesis_cb_tx()],
+                num_pages=1,
+                num_txs=1,
+            ),
+        )
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        tip = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)[-1]
+
+        coinvalue = 5000000000
+        tx1 = CTransaction()
+        tx1.vin = [
+            CTxIn(outpoint=COutPoint(int(cointx, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx1.vout = [
+            CTxOut(coinvalue - 10000, P2SH_OP_TRUE),
+            CTxOut(1000, CScript([OP_RETURN, b"test"])),
+        ]
+        tx1.rehash()
+
+        tx2 = CTransaction()
+        tx2.vin = [
+            CTxIn(outpoint=COutPoint(int(tx1.hash, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx2.vout = [
+            CTxOut(3000, CScript([OP_RETURN, b"test"])),
+            CTxOut(coinvalue - 20000, P2SH_OP_TRUE),
+        ]
+        tx2.rehash()
+
+        tx_coinbase = create_coinbase(102, b"\x03" * 33)
+
+        block = create_block(int(tip, 16), tx_coinbase, 1300000500)
+        block.vtx += [tx1, tx2]
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        block_metadata = pb.BlockMetadata(
+            height=102,
+            hash=bytes.fromhex(block.hash)[::-1],
+            timestamp=1300000500,
+        )
+
+        proto_coinbase_tx = pb.Tx(
+            txid=bytes.fromhex(tx_coinbase.hash)[::-1],
+            version=1,
+            inputs=[
+                pb.TxInput(
+                    prev_out=pb.OutPoint(txid=bytes(32), out_idx=0xFFFFFFFF),
+                    input_script=bytes(tx_coinbase.vin[0].scriptSig),
+                    sequence_no=0xFFFFFFFF,
+                ),
+            ],
+            outputs=[
+                pb.TxOutput(
+                    value=coinvalue,
+                    output_script=bytes(tx_coinbase.vout[0].scriptPubKey),
+                ),
+                pb.TxOutput(
+                    output_script=bytes(CScript([OP_RETURN])),
+                ),
+            ],
+            lock_time=0,
+            block=block_metadata,
+            size=len(tx_coinbase.serialize()),
+            is_coinbase=True,
+        )
+
+        proto_tx1 = pb.Tx(
+            txid=bytes.fromhex(tx1.hash)[::-1],
+            version=1,
+            inputs=[
+                pb.TxInput(
+                    prev_out=pb.OutPoint(txid=bytes.fromhex(cointx)[::-1], out_idx=0),
+                    input_script=bytes(SCRIPTSIG_OP_TRUE),
+                    output_script=bytes(P2SH_OP_TRUE),
+                    value=coinvalue,
+                    sequence_no=0,
+                ),
+            ],
+            outputs=[
+                pb.TxOutput(
+                    value=coinvalue - 10000,
+                    output_script=bytes(P2SH_OP_TRUE),
+                    spent_by=pb.SpentBy(
+                        txid=bytes.fromhex(tx2.hash)[::-1],
+                        input_idx=0,
+                    ),
+                ),
+                pb.TxOutput(
+                    value=1000,
+                    output_script=bytes(CScript([OP_RETURN, b"test"])),
+                ),
+            ],
+            lock_time=0,
+            size=len(tx1.serialize()),
+            block=block_metadata,
+        )
+
+        proto_tx2 = pb.Tx(
+            txid=bytes.fromhex(tx2.hash)[::-1],
+            version=1,
+            inputs=[
+                pb.TxInput(
+                    prev_out=pb.OutPoint(txid=bytes.fromhex(tx1.hash)[::-1], out_idx=0),
+                    input_script=bytes(SCRIPTSIG_OP_TRUE),
+                    output_script=bytes(P2SH_OP_TRUE),
+                    value=coinvalue - 10000,
+                    sequence_no=0,
+                ),
+            ],
+            outputs=[
+                pb.TxOutput(
+                    value=3000,
+                    output_script=bytes(CScript([OP_RETURN, b"test"])),
+                ),
+                pb.TxOutput(
+                    value=coinvalue - 20000,
+                    output_script=bytes(P2SH_OP_TRUE),
+                ),
+            ],
+            lock_time=0,
+            size=len(tx2.serialize()),
+            block=block_metadata,
+        )
+
+        sorted_tx1, sorted_tx2 = sorted(
+            [proto_tx1, proto_tx2], key=lambda tx: tx.txid[::-1]
+        )
+
+        for page, tx in enumerate([proto_coinbase_tx, sorted_tx1, sorted_tx2]):
+            assert_equal(
+                chronik.block_txs(block.hash, page=page, page_size=1).ok(),
+                pb.TxHistoryPage(
+                    txs=[tx],
+                    num_pages=3,
+                    num_txs=3,
+                ),
+            )
+
+        assert_equal(
+            chronik.block_txs(block.hash).ok(),
+            pb.TxHistoryPage(
+                txs=[proto_coinbase_tx, sorted_tx1, sorted_tx2],
+                num_pages=1,
+                num_txs=3,
+            ),
+        )
+
+        assert_equal(
+            chronik.block_txs(block.hash, page=0, page_size=2).ok(),
+            pb.TxHistoryPage(
+                txs=[proto_coinbase_tx, sorted_tx1],
+                num_pages=2,
+                num_txs=3,
+            ),
+        )
+        assert_equal(
+            chronik.block_txs(block.hash, page=1, page_size=2).ok(),
+            pb.TxHistoryPage(
+                txs=[sorted_tx2],
+                num_pages=2,
+                num_txs=3,
+            ),
+        )
+
+        node.invalidateblock(block.hash)
+        chronik.block_txs(block.hash).err(404)
+
+
+if __name__ == "__main__":
+    ChronikBlockTxsTest().main()
diff --git a/test/functional/chronik_blockchain_info.py b/test/functional/chronik_blockchain_info.py
new file mode 100644
index 000000000..7a8a78045
--- /dev/null
+++ b/test/functional/chronik_blockchain_info.py
@@ -0,0 +1,59 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /blockchain-info endpoint.
+"""
+
+from test_framework.address import ADDRESS_ECREG_UNSPENDABLE
+from test_framework.blocktools import GENESIS_BLOCK_HASH
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikBlockchainInfoTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        from test_framework.chronik.client import pb
+
+        assert_equal(
+            chronik.blockchain_info().ok(),
+            pb.BlockchainInfo(
+                tip_hash=bytes.fromhex(GENESIS_BLOCK_HASH)[::-1],
+                tip_height=0,
+            ),
+        )
+
+        block_hashes = self.generatetoaddress(node, 12, ADDRESS_ECREG_UNSPENDABLE)
+
+        assert_equal(
+            chronik.blockchain_info().ok(),
+            pb.BlockchainInfo(
+                tip_hash=bytes.fromhex(block_hashes[11])[::-1],
+                tip_height=12,
+            ),
+        )
+
+        node.invalidateblock(block_hashes[6])
+
+        assert_equal(
+            chronik.blockchain_info().ok(),
+            pb.BlockchainInfo(
+                tip_hash=bytes.fromhex(block_hashes[5])[::-1],
+                tip_height=6,
+            ),
+        )
+
+
+if __name__ == "__main__":
+    ChronikBlockchainInfoTest().main()
diff --git a/test/functional/chronik_blocks.py b/test/functional/chronik_blocks.py
new file mode 100644
index 000000000..2012f14b2
--- /dev/null
+++ b/test/functional/chronik_blocks.py
@@ -0,0 +1,101 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /blocks/:start_height/:end_height endpoint.
+"""
+
+from test_framework.address import ADDRESS_ECREG_UNSPENDABLE
+from test_framework.blocktools import GENESIS_BLOCK_HASH, TIME_GENESIS_BLOCK
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikBlockRangeTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        node.setmocktime(1300000000)
+        chronik = node.get_chronik_client()
+
+        assert_equal(
+            chronik.blocks(-1, 0).err(400).msg, "400: Invalid block start height: -1"
+        )
+        assert_equal(
+            chronik.blocks(-(2**31), 0).err(400).msg,
+            f"400: Invalid block start height: {-2**31}",
+        )
+        assert_equal(
+            chronik.blocks(2, 1).err(400).msg, "400: Invalid block end height: 1"
+        )
+        assert_equal(
+            chronik.blocks(1, 501).err(400).msg,
+            "400: Blocks page size too large, may not be above 500 but got 501",
+        )
+        # Doesn't overflow:
+        assert_equal(
+            chronik.blocks(0, 2**31 - 1).err(400).msg,
+            f"400: Blocks page size too large, may not be above 500 but got {2**31}",
+        )
+
+        from test_framework.chronik.client import pb
+
+        genesis_info = pb.BlockInfo(
+            hash=bytes.fromhex(GENESIS_BLOCK_HASH)[::-1],
+            prev_hash=bytes(32),
+            height=0,
+            n_bits=0x207FFFFF,
+            timestamp=TIME_GENESIS_BLOCK,
+            block_size=285,
+            num_txs=1,
+            num_inputs=1,
+            num_outputs=1,
+            sum_input_sats=0,
+            sum_coinbase_output_sats=5000000000,
+            sum_normal_output_sats=0,
+            sum_burned_sats=0,
+        )
+        assert_equal(chronik.blocks(0, 100).ok(), pb.Blocks(blocks=[genesis_info]))
+        assert_equal(chronik.blocks(0, 0).ok(), pb.Blocks(blocks=[genesis_info]))
+        assert_equal(chronik.blocks(500, 500).ok(), pb.Blocks(blocks=[]))
+        assert_equal(chronik.blocks(1, 500).ok(), pb.Blocks(blocks=[]))
+        assert_equal(chronik.blocks(500, 999).ok(), pb.Blocks(blocks=[]))
+        assert_equal(chronik.blocks(2**31 - 500, 2**31 - 1).ok(), pb.Blocks(blocks=[]))
+
+        block_hashes = [GENESIS_BLOCK_HASH]
+        block_hashes += self.generatetoaddress(node, 12, ADDRESS_ECREG_UNSPENDABLE)
+
+        assert_equal(
+            chronik.blocks(8, 12).ok(),
+            pb.Blocks(
+                blocks=[
+                    pb.BlockInfo(
+                        hash=bytes.fromhex(block_hashes[height])[::-1],
+                        prev_hash=bytes.fromhex(block_hashes[height - 1])[::-1],
+                        height=height,
+                        n_bits=0x207FFFFF,
+                        timestamp=1300000003,
+                        block_size=178,
+                        num_txs=1,
+                        num_inputs=1,
+                        num_outputs=1,
+                        sum_input_sats=0,
+                        sum_coinbase_output_sats=5000000000,
+                        sum_normal_output_sats=0,
+                        sum_burned_sats=0,
+                    )
+                    for height in range(8, 13)
+                ]
+            ),
+        )
+
+
+if __name__ == "__main__":
+    ChronikBlockRangeTest().main()
diff --git a/test/functional/chronik_chronik_info.py b/test/functional/chronik_chronik_info.py
new file mode 100644
index 000000000..25dac7bc6
--- /dev/null
+++ b/test/functional/chronik_chronik_info.py
@@ -0,0 +1,59 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /chronik-info endpoint.
+"""
+
+import os
+from pathlib import Path
+
+from test_framework.cdefs import get_srcdir
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+def get_chronik_version():
+    """
+    Get the chronik package version from Cargo.toml in chronik/chronik-http/
+
+    Assumptions
+    chronik version must be the first appearing version in the Cargo.toml file
+    Cargo.toml is at toplevel/chronik/chronik-http/Cargo.toml
+    """
+
+    # Get chronik version from Cargo.toml
+    basePath = get_srcdir()
+    cargo_path = os.path.join(basePath, "..", "..", "..", "chronik", "chronik-http", "Cargo.toml")
+    chronik_cargo_toml = Path(cargo_path).read_text()
+    for line in chronik_cargo_toml.split("\n"):
+        if "version =" in line:
+            # The chronik version appears at the highest line, between "" marks
+            return line.strip().split('"')[1]
+
+
+class ChronikChronikInfoTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        from test_framework.chronik.client import pb
+
+        assert_equal(
+            chronik.chronik_info().ok(),
+            pb.ChronikInfo(
+                version=get_chronik_version(),
+            ),
+        )
+
+
+if __name__ == "__main__":
+    ChronikChronikInfoTest().main()
diff --git a/test/functional/chronik_cors.py b/test/functional/chronik_cors.py
new file mode 100644
index 000000000..956d0d18c
--- /dev/null
+++ b/test/functional/chronik_cors.py
@@ -0,0 +1,41 @@
+# Copyright (c) 2022 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test -chronikcors works properly.
+"""
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikCorsTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        # By default we have no CORS headers
+        cors_headers = chronik.blockchain_info().response.headers
+        assert_equal(cors_headers["access-control-allow-origin"], None)
+        assert_equal(cors_headers["vary"], None)
+
+        self.restart_node(0, ["-chronik", "-chronikcors"])
+
+        # With -chronikcors, CORS headers are added
+        cors_headers = chronik.blockchain_info().response.headers
+        assert_equal(cors_headers["access-control-allow-origin"], "*")
+        vary_parts = {vary.strip() for vary in cors_headers["vary"].split(",")}
+        assert "access-control-request-method" in vary_parts
+        assert "access-control-request-headers" in vary_parts
+
+
+if __name__ == "__main__":
+    ChronikCorsTest().main()
diff --git a/test/functional/chronik_disable_token_index.py b/test/functional/chronik_disable_token_index.py
new file mode 100644
index 000000000..17ab7d96f
--- /dev/null
+++ b/test/functional/chronik_disable_token_index.py
@@ -0,0 +1,247 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's -chroniktokenindex=0 works properly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.alp import alp_genesis, alp_opreturn, alp_send
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikDisableTokenIndex(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def alp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        # ALP GENESIS tx
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[1000],
+                    num_batons=1,
+                ),
+            ),
+            CTxOut(20000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=1000),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        genesis_not_token = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NON_TOKEN,
+            entries=[],
+            inputs=[pb.Token()],
+            outputs=[pb.Token(), pb.Token(), pb.Token(), pb.Token()],
+        )
+        genesis.send(chronik)
+        genesis.test(chronik)
+
+        # ALP SEND tx
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(genesis.txid, 16), 1),
+                SCRIPTSIG_OP_TRUE,
+            ),
+        ]
+        tx.vout = [
+            alp_opreturn(
+                alp_send(
+                    token_id=genesis.txid,
+                    output_amounts=[300, 700],
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        send = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[
+                alp_token(token_id=genesis.txid, amount=1000),
+            ],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=genesis.txid, amount=300),
+                alp_token(token_id=genesis.txid, amount=700),
+            ],
+        )
+        send_not_token = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NON_TOKEN,
+            entries=[],
+            inputs=[pb.Token()],
+            outputs=[pb.Token(), pb.Token(), pb.Token()],
+        )
+        send.send(chronik)
+        send.test(chronik)
+        send_not_token = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NON_TOKEN,
+            entries=[],
+            inputs=[pb.Token()],
+            outputs=[pb.Token(), pb.Token(), pb.Token()],
+        )
+
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(COutPoint(int(send.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+        ]
+        tx.vout = [
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        burn = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    is_invalid=True,
+                    burn_summary="Unexpected burn: Burns 300 base tokens",
+                    actual_burn_amount="300",
+                ),
+            ],
+            inputs=[alp_token(token_id=genesis.txid, amount=300)],
+            outputs=[pb.Token(), pb.Token(), pb.Token()],
+        )
+        burn_not_token = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NON_TOKEN,
+            entries=[],
+            inputs=[pb.Token()],
+            outputs=[pb.Token(), pb.Token(), pb.Token()],
+        )
+        burn_error = f"400: Tx {burn.txid} failed token checks: Unexpected burn: Burns 300 base tokens."
+        burn.send(chronik, error=burn_error)
+        burn.test(chronik)
+
+        # With -chroniktokenindex=0, txs now have no token data anymore
+        self.restart_node(0, ["-chronik", "-chroniktokenindex=0"])
+        genesis_not_token.send(chronik)
+        genesis_not_token.test(chronik)
+        send_not_token.send(chronik)
+        send_not_token.test(chronik)
+        # No burn error reported anymore
+        burn_not_token.send(chronik)
+        burn_not_token.test(chronik)
+
+        # If we enable it again, we get an error
+        self.stop_node(0)
+        node.assert_start_raises_init_error(
+            extra_args=["-chronik", "-chroniktokenindex"],
+            expected_msg=(
+                "Error: Cannot enable -chroniktokenindex on a DB that previously had "
+                + "it disabled. Provide -reindex/-chronikreindex to reindex the "
+                + "database with token data, or specify -chroniktokenindex=0 to "
+                + "disable the token index again."
+            ),
+        )
+
+        # Specifying -chronikreindex makes it work
+        self.restart_node(0, ["-chronik", "-chroniktokenindex", "-chronikreindex"])
+        genesis.send(chronik)
+        genesis.test(chronik)
+        send.send(chronik)
+        send.test(chronik)
+        burn.send(chronik, error=burn_error)
+        burn.test(chronik)
+
+        # Mine txs to test token indexing for block txs
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        genesis.test(chronik, block_hash)
+        send.test(chronik, block_hash)
+        burn.test(chronik, block_hash)
+
+        # Restarting with -chroniktokenindex=0 wipes the token DB
+        with node.assert_debug_log(
+            [
+                "Warning: Wiping existing token index, since -chroniktokenindex=0",
+            ]
+        ):
+            self.restart_node(0, ["-chronik", "-chroniktokenindex=0"])
+        genesis_not_token.test(chronik, block_hash)
+        send_not_token.test(chronik, block_hash)
+        burn_not_token.test(chronik, block_hash)
+
+        # Invalidating the block sends txs back to the mempool
+        node.invalidateblock(block_hash)
+        genesis_not_token.test(chronik)
+        send_not_token.test(chronik)
+        burn_not_token.test(chronik)
+
+
+if __name__ == "__main__":
+    ChronikDisableTokenIndex().main()
diff --git a/test/functional/chronik_disallow_prune.py b/test/functional/chronik_disallow_prune.py
new file mode 100644
index 000000000..7e0e2d62e
--- /dev/null
+++ b/test/functional/chronik_disallow_prune.py
@@ -0,0 +1,28 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Verify combining -prune and -chronik results in an init error.
+"""
+
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikDisallowPruneTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        self.nodes[0].stop_node()
+        self.nodes[0].assert_start_raises_init_error(
+            ["-chronik", "-prune=1000"],
+            "Error: Prune mode is incompatible with -chronik.",
+        )
+
+
+if __name__ == "__main__":
+    ChronikDisallowPruneTest().main()
diff --git a/test/functional/chronik_lokad_id_group.py b/test/functional/chronik_lokad_id_group.py
new file mode 100644
index 000000000..126dd0cfc
--- /dev/null
+++ b/test/functional/chronik_lokad_id_group.py
@@ -0,0 +1,273 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes tx by LOKAD ID correctly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import create_block, create_coinbase
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import (
+    OP_EQUAL,
+    OP_HASH160,
+    OP_RESERVED,
+    OP_RETURN,
+    CScript,
+    hash160,
+)
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, chronik_sub_lokad_id
+
+
+class ChronikLokadIdGroup(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        node = self.nodes[0]
+        peer = node.add_p2p_connection(P2PDataStore())
+        chronik = node.get_chronik_client()
+        ws1 = chronik.ws()
+        ws2 = chronik.ws()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+        coinvalue = 5000000000
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        def p2lokad(lokad_id: bytes):
+            return CScript([lokad_id, OP_EQUAL])
+
+        def p2sh_lokad(lokad_id: bytes):
+            return CScript([OP_HASH160, hash160(p2lokad(lokad_id)), OP_EQUAL])
+
+        def spend_p2lokad(lokad_id: bytes):
+            return CScript([lokad_id, p2lokad(lokad_id)])
+
+        def page_txids(txs):
+            return [tx.txid[::-1].hex() for tx in txs]
+
+        def lokad_id_unconf(lokad_id: bytes):
+            return page_txids(
+                chronik.lokad_id(lokad_id.hex()).unconfirmed_txs().ok().txs
+            )
+
+        def lokad_id_conf(lokad_id: bytes):
+            return page_txids(chronik.lokad_id(lokad_id.hex()).confirmed_txs().ok().txs)
+
+        def lokad_id_history(lokad_id: bytes):
+            return page_txids(chronik.lokad_id(lokad_id.hex()).history().ok().txs)
+
+        def ws_msg(txid: str, msg_type):
+            return pb.WsMsg(
+                tx=pb.MsgTx(
+                    msg_type=msg_type,
+                    txid=bytes.fromhex(txid)[::-1],
+                )
+            )
+
+        chronik_sub_lokad_id(ws1, node, b"lok0")
+        chronik_sub_lokad_id(ws2, node, b"lok1")
+        chronik_sub_lokad_id(ws2, node, b"lok2")
+        chronik_sub_lokad_id(ws2, node, b"lok3")
+
+        tx0 = CTransaction()
+        tx0.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx0.vout = [
+            CTxOut(0, CScript([OP_RETURN, b"lok0"])),
+            CTxOut(10000, p2sh_lokad(b"lok1")),
+            CTxOut(10000, p2sh_lokad(b"lok2")),
+            CTxOut(10000, p2sh_lokad(b"lok3")),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx0.rehash()
+        chronik.broadcast_tx(tx0.serialize()).ok()
+        assert_equal(lokad_id_unconf(b"lok0"), [tx0.hash])
+
+        assert_equal(ws1.recv(), ws_msg(tx0.hash, pb.TX_ADDED_TO_MEMPOOL))
+
+        node.setmocktime(mocktime + 1)
+        tx1 = CTransaction()
+        tx1.vin = [CTxIn(COutPoint(tx0.sha256, 1), spend_p2lokad(b"lok1"))]
+        tx1.vout = [CTxOut(0, CScript([OP_RETURN, b"lok0", b"x" * 100]))]
+        tx1.rehash()
+        chronik.broadcast_tx(tx1.serialize()).ok()
+        assert_equal(lokad_id_unconf(b"lok0"), [tx0.hash, tx1.hash])
+        assert_equal(lokad_id_unconf(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_unconf(b"xxxx"), [])
+
+        assert_equal(ws1.recv(), ws_msg(tx1.hash, pb.TX_ADDED_TO_MEMPOOL))
+        assert_equal(ws2.recv(), ws_msg(tx1.hash, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Unsub ws2 from lok2
+        chronik_sub_lokad_id(ws2, node, b"lok2", is_unsub=True)
+
+        node.setmocktime(mocktime + 2)
+        tx2 = CTransaction()
+        tx2.vin = [CTxIn(COutPoint(tx0.sha256, 2), spend_p2lokad(b"lok2"))]
+        tx2.vout = [
+            CTxOut(
+                0, CScript([OP_RETURN, OP_RESERVED, b"lok2__", b"lok0" + b"x" * 100])
+            )
+        ]
+        tx2.rehash()
+        chronik.broadcast_tx(tx2.serialize()).ok()
+        assert_equal(lokad_id_unconf(b"lok0"), [tx0.hash, tx1.hash, tx2.hash])
+        assert_equal(lokad_id_unconf(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_unconf(b"lok2"), [tx2.hash])
+
+        # Only sent to ws1, not ws2
+        assert_equal(ws1.recv(), ws_msg(tx2.hash, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Mine tx0, tx1, tx2
+        blockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+
+        assert_equal(lokad_id_conf(b"lok0"), sorted([tx0.hash, tx1.hash, tx2.hash]))
+        assert_equal(lokad_id_conf(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_conf(b"lok2"), [tx2.hash])
+
+        for txid in sorted([tx0.hash, tx1.hash, tx2.hash]):
+            assert_equal(ws1.recv(), ws_msg(txid, pb.TX_CONFIRMED))
+        assert_equal(ws2.recv(), ws_msg(tx1.hash, pb.TX_CONFIRMED))
+
+        tx3 = CTransaction()
+        tx3.vin = [CTxIn(COutPoint(tx0.sha256, 3), spend_p2lokad(b"lok3"))]
+        tx3.vout = [
+            CTxOut(0, CScript([OP_RETURN, OP_RESERVED, b"lok2", b"lok0" + b"x" * 100]))
+        ]
+        tx3.rehash()
+        chronik.broadcast_tx(tx3.serialize()).ok()
+
+        assert_equal(ws1.recv(), ws_msg(tx3.hash, pb.TX_ADDED_TO_MEMPOOL))
+        assert_equal(ws2.recv(), ws_msg(tx3.hash, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Unconfirmed
+        assert_equal(lokad_id_unconf(b"lok0"), [tx3.hash])
+        assert_equal(lokad_id_unconf(b"lok1"), [])
+        assert_equal(lokad_id_unconf(b"lok2"), [tx3.hash])
+        assert_equal(lokad_id_unconf(b"lok3"), [tx3.hash])
+        # Confirmed stays unchanged
+        assert_equal(lokad_id_conf(b"lok0"), sorted([tx0.hash, tx1.hash, tx2.hash]))
+        assert_equal(lokad_id_conf(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_conf(b"lok2"), [tx2.hash])
+        assert_equal(lokad_id_conf(b"lok3"), [])
+        # History
+        assert_equal(
+            lokad_id_history(b"lok0"), [tx3.hash, tx2.hash, tx1.hash, tx0.hash]
+        )
+        assert_equal(lokad_id_history(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_history(b"lok2"), [tx3.hash, tx2.hash])
+        assert_equal(lokad_id_history(b"lok3"), [tx3.hash])
+
+        # Mine conflicting tx kicking out tx3
+        tx3_conflict = CTransaction()
+        tx3_conflict.vin = [CTxIn(COutPoint(tx0.sha256, 3), spend_p2lokad(b"lok3"))]
+        tx3_conflict.vout = [
+            CTxOut(0, CScript([OP_RETURN, OP_RESERVED, b"lok4" + b"x" * 100]))
+        ]
+        tx3_conflict.rehash()
+
+        block = create_block(int(blockhash, 16), create_coinbase(103), mocktime + 100)
+        block.vtx += [tx3_conflict]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        assert_equal(ws1.recv(), ws_msg(tx3.hash, pb.TX_REMOVED_FROM_MEMPOOL))
+        assert_equal(ws2.recv(), ws_msg(tx3.hash, pb.TX_REMOVED_FROM_MEMPOOL))
+
+        assert_equal(ws2.recv(), ws_msg(tx3_conflict.hash, pb.TX_CONFIRMED))
+
+        # No unconfirmed anymore
+        assert_equal(lokad_id_unconf(b"lok0"), [])
+        assert_equal(lokad_id_unconf(b"lok1"), [])
+        assert_equal(lokad_id_unconf(b"lok2"), [])
+        assert_equal(lokad_id_unconf(b"lok3"), [])
+        # Confirmed
+        assert_equal(lokad_id_conf(b"lok0"), sorted([tx0.hash, tx1.hash, tx2.hash]))
+        assert_equal(lokad_id_conf(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_conf(b"lok2"), [tx2.hash])
+        assert_equal(lokad_id_conf(b"lok3"), [tx3_conflict.hash])
+        assert_equal(lokad_id_conf(b"lok4"), [tx3_conflict.hash])
+        # History
+        assert_equal(lokad_id_history(b"lok0"), [tx2.hash, tx1.hash, tx0.hash])
+        assert_equal(lokad_id_history(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_history(b"lok2"), [tx2.hash])
+        assert_equal(lokad_id_history(b"lok3"), [tx3_conflict.hash])
+        assert_equal(lokad_id_history(b"lok4"), [tx3_conflict.hash])
+
+        node.invalidateblock(block.hash)
+
+        assert_equal(ws2.recv(), ws_msg(tx3_conflict.hash, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Back to unconfirmed
+        assert_equal(lokad_id_unconf(b"lok0"), [])
+        assert_equal(lokad_id_unconf(b"lok1"), [])
+        assert_equal(lokad_id_unconf(b"lok2"), [])
+        assert_equal(lokad_id_unconf(b"lok3"), [tx3_conflict.hash])
+        assert_equal(lokad_id_unconf(b"lok4"), [tx3_conflict.hash])
+        # Confirmed
+        assert_equal(lokad_id_conf(b"lok0"), sorted([tx0.hash, tx1.hash, tx2.hash]))
+        assert_equal(lokad_id_conf(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_conf(b"lok2"), [tx2.hash])
+        assert_equal(lokad_id_conf(b"lok3"), [])
+        assert_equal(lokad_id_conf(b"lok4"), [])
+        # History
+        assert_equal(lokad_id_history(b"lok0"), [tx2.hash, tx1.hash, tx0.hash])
+        assert_equal(lokad_id_history(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_history(b"lok2"), [tx2.hash])
+        assert_equal(lokad_id_history(b"lok3"), [tx3_conflict.hash])
+        assert_equal(lokad_id_history(b"lok4"), [tx3_conflict.hash])
+
+        # Restarting leaves the LOKAD index intact
+        self.restart_node(0, ["-chronik"])
+        assert_equal(lokad_id_history(b"lok0"), [tx2.hash, tx1.hash, tx0.hash])
+        assert_equal(lokad_id_history(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_history(b"lok2"), [tx2.hash])
+
+        # Restarting with index disabled wipes the DB
+        self.restart_node(0, ["-chronik", "-chroniklokadidindex=0"])
+        assert_equal(lokad_id_history(b"lok0"), [])
+        assert_equal(lokad_id_history(b"lok1"), [])
+        assert_equal(lokad_id_history(b"lok2"), [])
+
+        # Restarting with chroniklokadidindex=1 reindexes the LOKAD ID index
+        self.restart_node(0, ["-chronik"])
+        assert_equal(lokad_id_history(b"lok0"), [tx2.hash, tx1.hash, tx0.hash])
+        assert_equal(lokad_id_history(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_history(b"lok2"), [tx2.hash])
+
+        # Restarting again still leaves the index intact
+        self.restart_node(0, ["-chronik", "-chroniklokadidindex=1"])
+        assert_equal(lokad_id_history(b"lok0"), [tx2.hash, tx1.hash, tx0.hash])
+        assert_equal(lokad_id_history(b"lok1"), [tx1.hash])
+        assert_equal(lokad_id_history(b"lok2"), [tx2.hash])
+
+        # Wipe index again
+        self.restart_node(0, ["-chronik", "-chroniklokadidindex=0"])
+        assert_equal(lokad_id_history(b"lok0"), [])
+        assert_equal(lokad_id_history(b"lok1"), [])
+        assert_equal(lokad_id_history(b"lok2"), [])
+
+
+if __name__ == "__main__":
+    ChronikLokadIdGroup().main()
diff --git a/test/functional/chronik_mempool_conflicts.py b/test/functional/chronik_mempool_conflicts.py
new file mode 100644
index 000000000..3401efce3
--- /dev/null
+++ b/test/functional/chronik_mempool_conflicts.py
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik resolving mempool conflicts gracefully
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import create_block, create_coinbase
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+
+
+class ChronikMempoolConflicts(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import ChronikClient
+
+        node = self.nodes[0]
+        chronik = ChronikClient("127.0.0.1", node.chronik_port)
+
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        block_hashes = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        tx1 = CTransaction()
+        tx1.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx1.vout = [
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx1.rehash()
+        node.sendrawtransaction(tx1.serialize().hex())
+
+        tx2 = CTransaction()
+        tx2.vin = [
+            CTxIn(
+                COutPoint(int(tx1.hash, 16), 1),
+                SCRIPTSIG_OP_TRUE,
+            )
+        ]
+        tx2.vout = [
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 200000, P2SH_OP_TRUE),
+        ]
+        tx2.rehash()
+        node.sendrawtransaction(tx2.serialize().hex())
+
+        tx3 = CTransaction()
+        tx3.vin = [
+            CTxIn(
+                COutPoint(int(tx1.hash, 16), 0),
+                SCRIPTSIG_OP_TRUE,
+            ),
+            CTxIn(COutPoint(int(tx2.hash, 16), 0), SCRIPTSIG_OP_TRUE),
+        ]
+        tx3.vout = [CTxOut(546, P2SH_OP_TRUE)]
+        tx3.rehash()
+        node.sendrawtransaction(tx3.serialize().hex())
+
+        # Kicking out all txs from the mempool by mining 1 conflict
+        block_height = 102
+        conflict_tx = CTransaction()
+        conflict_tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        pad_tx(conflict_tx)
+        block = create_block(
+            int(block_hashes[-1], 16),
+            create_coinbase(block_height, b"\x03" * 33),
+        )
+        block.vtx += [conflict_tx]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        chronik.tx(tx1.hash).err(404)
+        chronik.tx(tx2.hash).err(404)
+        chronik.tx(tx3.hash).err(404)
+
+
+if __name__ == "__main__":
+    ChronikMempoolConflicts().main()
diff --git a/test/functional/chronik_pause.py b/test/functional/chronik_pause.py
new file mode 100644
index 000000000..2aab9618e
--- /dev/null
+++ b/test/functional/chronik_pause.py
@@ -0,0 +1,161 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+import time
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal
+
+
+class ChronikPauseTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        chronik.pause().err(403)
+        chronik.resume().err(403)
+
+        self.log.info("Restart to allow pause")
+        self.restart_node(0, ["-chronik", "-chronikallowpause"])
+        node.setmocktime(1300000000)
+
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        self.log.info("Generate coin + mature for testing")
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+        coinvalue = 5000000000
+        tip = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)[-1]
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [CTxOut(coinvalue - 10_000, P2SH_OP_TRUE)]
+        pad_tx(tx)
+
+        self.log.info("Pause Chronik indexing")
+        chronik.pause().ok()
+        chronik.pause().ok()  # Noop, allowed
+        self.log.info("Send using P2P network")
+        # sendrawtransaction calls SyncWithValidationInterfaceQueue, which would
+        # block forever, using send_txs_and_test avoids this.
+        peer.send_txs_and_test([tx], node)
+
+        self.log.info("Tx not yet picked up by chronik")
+        time.sleep(0.1)
+        chronik.tx(tx.hash).err(404)
+
+        self.log.info("Resume indexing and sync Chronik")
+        chronik.resume().ok()
+        chronik.resume().ok()  # Noop, allowed
+        node.syncwithvalidationinterfacequeue()
+
+        self.log.info("Chronik has now indexed the tx")
+        chronik.tx(tx.hash).ok()
+
+        self.log.info("Pause Chronik indexing for block processing")
+        chronik.pause().ok()
+
+        self.log.info("Create block with conflicting tx")
+        conflict_tx = CTransaction(tx)
+        conflict_tx.nVersion = 2
+        conflict_tx.rehash()
+        blockA = create_block(
+            int(tip, 16), create_coinbase(102, b"\x03" * 33), 1300000500
+        )
+        blockA.vtx += [conflict_tx]
+        make_conform_to_ctor(blockA)
+        blockA.hashMerkleRoot = blockA.calc_merkle_root()
+        blockA.solve()
+        peer.send_blocks_and_test([blockA], node, timeout=5)
+
+        self.log.info("Block not indexed yet")
+        time.sleep(0.1)
+        chronik.block(blockA.hash).err(404)
+
+        self.log.info("Chronik still believes the old tx exists")
+        chronik.tx(tx.hash).ok()
+        chronik.tx(conflict_tx.hash).err(404)
+
+        self.log.info("Resume indexing and sync Chronik")
+        chronik.resume().ok()
+        node.syncwithvalidationinterfacequeue()
+
+        self.log.info("Block now indexed and tx conflict resolved")
+        chronik.block(blockA.hash).ok()
+        chronik.tx(tx.hash).err(404)
+        chronik.tx(conflict_tx.hash).ok()
+
+        self.log.info("Pause Chronik for reorg")
+        chronik.pause().ok()
+
+        self.log.info("Reorg last block by mining two blocks")
+        blockB1 = create_block(
+            int(tip, 16), create_coinbase(102, b"\x03" * 33), 1300000500
+        )
+        blockB1.solve()
+
+        blockB2 = create_block(
+            blockB1.sha256, create_coinbase(103, b"\x03" * 33), 1300000500
+        )
+        blockB2.solve()
+
+        peer.send_blocks_and_test([blockB1, blockB2], node)
+
+        self.log.info("Reorg returns tx to mempool")
+        assert (
+            conflict_tx.hash in node.getrawmempool()
+        ), f"{conflict_tx.hash} not found in mempool"
+
+        self.log.info("Chronik still thinks blockA exists")
+        time.sleep(0.1)
+        chronik.block(blockA.hash).ok()
+        chronik.block(blockB1.hash).err(404)
+        chronik.block(blockB2.hash).err(404)
+
+        self.log.info("Add block that mines the tx")
+        blockB3 = create_block(
+            blockB2.sha256, create_coinbase(104, b"\x03" * 33), 1300000500
+        )
+        blockB3.vtx += [conflict_tx]
+        make_conform_to_ctor(blockB3)
+        blockB3.hashMerkleRoot = blockB3.calc_merkle_root()
+        blockB3.solve()
+        peer.send_blocks_and_test([blockB3], node)
+
+        self.log.info("Resume indexing and sync Chronik")
+        chronik.resume().ok()
+        node.syncwithvalidationinterfacequeue()
+
+        # Check if spent coins are indexed correctly
+        tx_proto = chronik.tx(conflict_tx.hash).ok()
+        assert_equal(tx_proto.inputs[0].output_script, bytes(P2SH_OP_TRUE))
+        assert_equal(tx_proto.inputs[0].value, coinvalue)
+
+
+if __name__ == "__main__":
+    ChronikPauseTest().main()
diff --git a/test/functional/chronik_plugins_setup.py b/test/functional/chronik_plugins_setup.py
new file mode 100644
index 000000000..56a821389
--- /dev/null
+++ b/test/functional/chronik_plugins_setup.py
@@ -0,0 +1,27 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test the Chronik plugin system gets sets up correctly.
+"""
+
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikPluginsSetup(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik_plugins()
+
+    def run_test(self):
+        node = self.nodes[0]
+        with node.assert_debug_log(["Plugin context initialized Python"]):
+            self.restart_node(0, ["-chronik"])
+
+
+if __name__ == "__main__":
+    ChronikPluginsSetup().main()
diff --git a/test/functional/chronik_raw_tx.py b/test/functional/chronik_raw_tx.py
new file mode 100644
index 000000000..e1d140115
--- /dev/null
+++ b/test/functional/chronik_raw_tx.py
@@ -0,0 +1,104 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /raw-tx/:txid endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import GENESIS_CB_TXID
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.script import OP_EQUAL, OP_HASH160, CScript, hash160
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikRawTxTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        assert_equal(chronik.tx("0").err(400).msg, "400: Not a txid: 0")
+        assert_equal(chronik.tx("123").err(400).msg, "400: Not a txid: 123")
+        assert_equal(chronik.tx("1234f").err(400).msg, "400: Not a txid: 1234f")
+        assert_equal(chronik.tx("00" * 31).err(400).msg, f'400: Not a txid: {"00"*31}')
+        assert_equal(chronik.tx("01").err(400).msg, "400: Not a txid: 01")
+        assert_equal(
+            chronik.tx("12345678901").err(400).msg, "400: Not a txid: 12345678901"
+        )
+
+        assert_equal(
+            chronik.tx("00" * 32).err(404).msg,
+            f'404: Transaction {"00"*32} not found in the index',
+        )
+
+        from test_framework.chronik.client import pb
+
+        # Verify queried genesis tx matches
+        # Note: unlike getrawtransaction, this also works on the Genesis coinbase
+        assert_equal(
+            chronik.raw_tx(GENESIS_CB_TXID).ok(),
+            pb.RawTx(
+                raw_tx=bytes.fromhex(
+                    "0100000001000000000000000000000000000000000000000000000000000000000000"
+                    "0000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f323030"
+                    "39204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e6420626169"
+                    "6c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe"
+                    "5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4"
+                    "f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000"
+                )
+            ),
+        )
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+        send_values = [coinvalue - 10000, 1000, 2000, 3000]
+        send_redeem_scripts = [bytes([i + 0x52]) for i in range(len(send_values))]
+        send_scripts = [
+            CScript([OP_HASH160, hash160(redeem_script), OP_EQUAL])
+            for redeem_script in send_redeem_scripts
+        ]
+        tx = CTransaction()
+        tx.nVersion = 2
+        tx.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(cointx, 16), 0),
+                scriptSig=SCRIPTSIG_OP_TRUE,
+                nSequence=0xFFFFFFFE,
+            )
+        ]
+        tx.vout = [
+            CTxOut(value, script) for (value, script) in zip(send_values, send_scripts)
+        ]
+        tx.nLockTime = 1234567890
+
+        # Submit tx to mempool
+        raw_tx = tx.serialize()
+        txid = node.sendrawtransaction(raw_tx.hex())
+        assert_equal(chronik.raw_tx(txid).ok(), pb.RawTx(raw_tx=raw_tx))
+
+        # Mined block still works
+        self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)
+        assert_equal(chronik.raw_tx(txid).ok(), pb.RawTx(raw_tx=raw_tx))
+
+
+if __name__ == "__main__":
+    ChronikRawTxTest().main()
diff --git a/test/functional/chronik_resync.py b/test/functional/chronik_resync.py
new file mode 100644
index 000000000..c578a34c0
--- /dev/null
+++ b/test/functional/chronik_resync.py
@@ -0,0 +1,126 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+import os
+import shutil
+
+from test_framework.address import ADDRESS_ECREG_P2SH_OP_TRUE, ADDRESS_ECREG_UNSPENDABLE
+from test_framework.blocktools import GENESIS_BLOCK_HASH
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, get_datadir_path
+
+
+class ChronikResyncTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        # Mine 100 blocks, that Chronik doesn't index
+        block_hashes = [GENESIS_BLOCK_HASH] + self.generatetoaddress(
+            node, 100, ADDRESS_ECREG_P2SH_OP_TRUE
+        )
+
+        # Restart with Chronik: syncs blocks from genesis
+        with node.assert_debug_log(
+            [
+                f"Chronik database empty, syncing to block {block_hashes[100]} "
+                + "at height 100.",
+            ]
+        ):
+            self.restart_node(0, ["-chronik"])
+
+        for i in range(0, 101):
+            proto_block = chronik.block(i).ok()
+            assert_equal(proto_block.block_info.hash[::-1].hex(), block_hashes[i])
+
+        chronik.block(101).err(404)
+
+        self.restart_node(0, [])
+
+        # Without Chronik: Undo last 50 blocks, then add 100 new ones
+        node.invalidateblock(block_hashes[50])
+        chronik_hash = block_hashes[100]
+        del block_hashes[50:]
+        block_hashes += self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        # Restart with Chronik: Undoes last 50 blocks, then adds node's next 100
+        with node.assert_debug_log(
+            [
+                f"Node and Chronik diverged, node is on block {block_hashes[149]} "
+                + f"at height 149, and Chronik is on block {chronik_hash} at height"
+                " 100.",
+                f"The last common block is {block_hashes[49]} at height 49.",
+                "Reverting Chronik blocks 50 to 100",
+            ]
+        ):
+            self.restart_node(0, ["-chronik"])
+
+        for i in range(0, 150):
+            proto_block = chronik.block(i).ok()
+            assert_equal(proto_block.block_info.hash[::-1].hex(), block_hashes[i])
+
+        chronik.block(150).err(404)
+
+        # Reset node blockchain back to genesis
+        # Leave Chronik untouched
+        node.stop_node()
+        datadir = get_datadir_path(self.options.tmpdir, 0)
+        shutil.rmtree(os.path.join(datadir, self.chain, "blocks"))
+        shutil.rmtree(os.path.join(datadir, self.chain, "chainstate"))
+
+        # Chronik cannot sync because the node doesn't have the old blocks anymore
+        # It needs the node's block data to undo the stale blocks.
+        init_error_msg = (
+            f"Error: Cannot rewind Chronik, it contains block {block_hashes[149]} "
+            + "that the node doesn't have. You may need to use -reindex/"
+            + "-chronikreindex, or delete indexes/chronik and restart"
+        )
+        node.assert_start_raises_init_error(["-chronik"], init_error_msg)
+
+        # Reindexing results in the same error (different code path)
+        self.restart_node(0, ["-reindex"])
+        assert_equal(node.getbestblockhash(), GENESIS_BLOCK_HASH)
+
+        node.stop_node()
+        node.assert_start_raises_init_error(["-chronik"], init_error_msg)
+
+        # Reindexing with -chronik now works, as it wipes the Chronik data
+        with node.assert_debug_log(["Wiping Chronik at "]):
+            self.restart_node(0, ["-chronik", "-reindex"])
+        chronik.block(0).ok()
+        chronik.block(1).err(404)
+
+        # Generate 100 blocks without chronik
+        self.restart_node(0, [])
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_P2SH_OP_TRUE)
+
+        # Reindexing indexes 100 blocks
+        self.restart_node(0, ["-chronik", "-reindex"])
+        chronik.block(100).ok()
+
+        # Test -chronikreindex
+        with node.assert_debug_log(["Wiping Chronik at "]):
+            self.restart_node(0, ["-chronik", "-chronikreindex"])
+        chronik.block(0).ok()
+        chronik.block(100).ok()
+        chronik.block(101).err(404)
+
+        # Simply restarting the node fully synced doesn't log any divergence
+        with node.assert_debug_log(
+            ["Chronik completed re-syncing with the node"],
+            unexpected_msgs=["Node and Chronik diverged"],
+        ):
+            self.restart_node(0, ["-chronik"])
+
+
+if __name__ == "__main__":
+    ChronikResyncTest().main()
diff --git a/test/functional/chronik_script_confirmed_txs.py b/test/functional/chronik_script_confirmed_txs.py
new file mode 100644
index 000000000..8ef22a594
--- /dev/null
+++ b/test/functional/chronik_script_confirmed_txs.py
@@ -0,0 +1,223 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /script/:type/:payload/confirmed-txs endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import GENESIS_CB_PK, create_block, create_coinbase
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal, iter_chunks
+
+
+class ChronikScriptConfirmedTxsTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        assert_equal(
+            chronik.script("", "").confirmed_txs().err(400).msg,
+            "400: Unknown script type: ",
+        )
+        assert_equal(
+            chronik.script("foo", "").confirmed_txs().err(400).msg,
+            "400: Unknown script type: foo",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "LILALI").confirmed_txs().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("other", "LILALI").confirmed_txs().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "").confirmed_txs().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 0 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "aA").confirmed_txs().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 1 bytes",
+        )
+        assert_equal(
+            chronik.script("p2sh", "aaBB").confirmed_txs().err(400).msg,
+            "400: Invalid payload for P2SH: Invalid length, "
+            + "expected 20 bytes but got 2 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pk", "aaBBcc").confirmed_txs().err(400).msg,
+            "400: Invalid payload for P2PK: Invalid length, "
+            + "expected one of [33, 65] but got 3 bytes",
+        )
+
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .confirmed_txs(page=0, page_size=201)
+            .err(400)
+            .msg,
+            "400: Requested page size 201 is too big, maximum is 200",
+        )
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .confirmed_txs(page=0, page_size=0)
+            .err(400)
+            .msg,
+            "400: Requested page size 0 is too small, minimum is 1",
+        )
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .confirmed_txs(page=0, page_size=2**32)
+            .err(400)
+            .msg,
+            "400: Invalid param page_size: 4294967296, "
+            + "number too large to fit in target type",
+        )
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .confirmed_txs(page=2**32, page_size=1)
+            .err(400)
+            .msg,
+            "400: Invalid param page: 4294967296, "
+            + "number too large to fit in target type",
+        )
+
+        from test_framework.chronik.client import pb
+
+        # Handle overflow gracefully on 32-bit
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .confirmed_txs(page=2**32 - 1, page_size=200)
+            .ok(),
+            pb.TxHistoryPage(num_pages=1, num_txs=1),
+        )
+
+        genesis_db_script_history = (
+            chronik.script("p2pk", GENESIS_CB_PK).confirmed_txs().ok()
+        )
+        from test_framework.chronik.test_data import genesis_cb_tx
+
+        assert_equal(
+            genesis_db_script_history,
+            pb.TxHistoryPage(txs=[genesis_cb_tx()], num_pages=1, num_txs=1),
+        )
+
+        script_type = "p2sh"
+        payload_hex = P2SH_OP_TRUE[2:-1].hex()
+
+        # Generate 101 blocks to some address and verify pages
+        blockhashes = self.generatetoaddress(node, 101, ADDRESS_ECREG_P2SH_OP_TRUE)
+
+        def check_confirmed_txs(txs, *, page_size=25):
+            pages = list(iter_chunks(txs, page_size))
+            for page_num, page_txs in enumerate(pages):
+                script_history = (
+                    chronik.script(script_type, payload_hex)
+                    .confirmed_txs(page_num, page_size)
+                    .ok()
+                )
+                for tx_idx, entry in enumerate(page_txs):
+                    script_tx = script_history.txs[tx_idx]
+                    if "txid" in entry:
+                        assert_equal(script_tx.txid[::-1].hex(), entry["txid"])
+                    if "block" in entry:
+                        block_height, block_hash = entry["block"]
+                        assert_equal(
+                            script_tx.block,
+                            pb.BlockMetadata(
+                                hash=bytes.fromhex(block_hash)[::-1],
+                                height=block_height,
+                                timestamp=script_tx.block.timestamp,
+                            ),
+                        )
+
+        txs = [{"block": (i + 1, blockhash)} for i, blockhash in enumerate(blockhashes)]
+        check_confirmed_txs(txs)
+        check_confirmed_txs(txs, page_size=200)
+
+        # Undo last block & check history
+        node.invalidateblock(blockhashes[-1])
+        check_confirmed_txs(txs[:-1])
+        check_confirmed_txs(txs[:-1], page_size=200)
+
+        # Create 1 block manually
+        coinbase_tx = create_coinbase(101)
+        coinbase_tx.vout[0].scriptPubKey = P2SH_OP_TRUE
+        coinbase_tx.rehash()
+        block = create_block(int(blockhashes[-2], 16), coinbase_tx, mocktime + 1000)
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        blockhashes[-1] = block.hash
+
+        txs = [{"block": (i + 1, blockhash)} for i, blockhash in enumerate(blockhashes)]
+        check_confirmed_txs(txs)
+        check_confirmed_txs(txs, page_size=200)
+
+        # Generate 900 more blocks and verify
+        # Total of 1001 txs for this script (a page in the DB is 1000 entries long)
+        blockhashes += self.generatetoaddress(node, 900, ADDRESS_ECREG_P2SH_OP_TRUE)
+        txs = [{"block": (i + 1, blockhash)} for i, blockhash in enumerate(blockhashes)]
+        page_sizes = [1, 5, 7, 25, 111, 200]
+        for page_size in page_sizes:
+            check_confirmed_txs(txs, page_size=page_size)
+
+        coinvalue = 5000000000
+        cointxids = []
+        for coinblockhash in blockhashes[:10]:
+            coinblock = node.getblock(coinblockhash)
+            cointxids.append(coinblock["tx"][0])
+
+        mempool_txids = []
+        for cointxid in cointxids:
+            tx = CTransaction()
+            tx.nVersion = 1
+            tx.vin = [
+                CTxIn(
+                    outpoint=COutPoint(int(cointxid, 16), 0),
+                    scriptSig=SCRIPTSIG_OP_TRUE,
+                )
+            ]
+            tx.vout = [CTxOut(coinvalue - 1000, P2SH_OP_TRUE)]
+            pad_tx(tx)
+            txid = node.sendrawtransaction(tx.serialize().hex())
+            mempool_txids.append(txid)
+
+        # confirmed-txs completely unaffected by mempool txs
+        for page_size in page_sizes:
+            check_confirmed_txs(txs, page_size=page_size)
+
+        # Mine mempool txs, now they're in confirmed-txs
+        newblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        txs.append({"block": (1002, newblockhash)})
+        txs += [
+            {"block": (1002, newblockhash), "txid": txid}
+            for txid in sorted(mempool_txids)
+        ]
+        for page_size in page_sizes:
+            check_confirmed_txs(txs, page_size=page_size)
+
+
+if __name__ == "__main__":
+    ChronikScriptConfirmedTxsTest().main()
diff --git a/test/functional/chronik_script_history.py b/test/functional/chronik_script_history.py
new file mode 100644
index 000000000..5fec23996
--- /dev/null
+++ b/test/functional/chronik_script_history.py
@@ -0,0 +1,296 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /script/:type/:payload/history endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    GENESIS_CB_PK,
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal, iter_chunks
+
+
+class ChronikScriptHistoryTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        assert_equal(
+            chronik.script("", "").history().err(400).msg, "400: Unknown script type: "
+        )
+        assert_equal(
+            chronik.script("foo", "").history().err(400).msg,
+            "400: Unknown script type: foo",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "LILALI").history().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("other", "LILALI").history().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "").history().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 0 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "aA").history().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 1 bytes",
+        )
+        assert_equal(
+            chronik.script("p2sh", "aaBB").history().err(400).msg,
+            "400: Invalid payload for P2SH: Invalid length, "
+            + "expected 20 bytes but got 2 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pk", "aaBBcc").history().err(400).msg,
+            "400: Invalid payload for P2PK: Invalid length, "
+            + "expected one of [33, 65] but got 3 bytes",
+        )
+
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .history(page=0, page_size=201)
+            .err(400)
+            .msg,
+            "400: Requested page size 201 is too big, maximum is 200",
+        )
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .history(page=0, page_size=0)
+            .err(400)
+            .msg,
+            "400: Requested page size 0 is too small, minimum is 1",
+        )
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .history(page=0, page_size=2**32)
+            .err(400)
+            .msg,
+            "400: Invalid param page_size: 4294967296, "
+            + "number too large to fit in target type",
+        )
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .history(page=2**32, page_size=1)
+            .err(400)
+            .msg,
+            "400: Invalid param page: 4294967296, "
+            + "number too large to fit in target type",
+        )
+
+        from test_framework.chronik.client import pb
+
+        # Handle overflow gracefully on 32-bit
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK)
+            .history(page=2**32 - 1, page_size=200)
+            .ok(),
+            pb.TxHistoryPage(num_pages=1, num_txs=1),
+        )
+
+        genesis_db_script_history = chronik.script("p2pk", GENESIS_CB_PK).history().ok()
+        from test_framework.chronik.test_data import genesis_cb_tx
+
+        assert_equal(
+            genesis_db_script_history,
+            pb.TxHistoryPage(txs=[genesis_cb_tx()], num_pages=1, num_txs=1),
+        )
+
+        script_type = "p2sh"
+        payload_hex = P2SH_OP_TRUE[2:-1].hex()
+
+        def check_tx_history(mempooltxs, blocktxs, *, page_size=25):
+            pages = list(iter_chunks(mempooltxs + blocktxs, page_size))
+            for page_num, page_txs in enumerate(pages):
+                script_history = (
+                    chronik.script(script_type, payload_hex)
+                    .history(page=page_num, page_size=page_size)
+                    .ok()
+                )
+                assert_equal(script_history.num_pages, len(pages))
+                assert_equal(script_history.num_txs, len(mempooltxs) + len(blocktxs))
+                for tx_idx, entry in enumerate(page_txs):
+                    script_tx = script_history.txs[tx_idx]
+                    if "txid" in entry:
+                        assert_equal(script_tx.txid[::-1].hex(), entry["txid"])
+                    if "time_first_seen" in entry:
+                        assert_equal(
+                            script_tx.time_first_seen, entry["time_first_seen"]
+                        )
+                    if "block" in entry:
+                        block_height, block_hash = entry["block"]
+                        assert_equal(
+                            script_tx.block,
+                            pb.BlockMetadata(
+                                hash=bytes.fromhex(block_hash)[::-1],
+                                height=block_height,
+                                timestamp=script_tx.block.timestamp,
+                            ),
+                        )
+
+        # Generate 101 blocks to some address and verify pages
+        blockhashes = self.generatetoaddress(node, 101, ADDRESS_ECREG_P2SH_OP_TRUE)
+        blocktxs = [{"block": (i, blockhashes[i - 1])} for i in range(101, 0, -1)]
+        check_tx_history([], blocktxs)
+        check_tx_history([], blocktxs, page_size=200)
+
+        # Undo last block & check history
+        node.invalidateblock(blockhashes[-1])
+        check_tx_history([], blocktxs[1:])
+        check_tx_history([], blocktxs[1:], page_size=200)
+
+        # Create 1 block manually (with out-of-order block time)
+        coinbase_tx = create_coinbase(101)
+        coinbase_tx.vout[0].scriptPubKey = P2SH_OP_TRUE
+        coinbase_tx.rehash()
+        block = create_block(int(blockhashes[-2], 16), coinbase_tx, mocktime + 1000)
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        blockhashes[-1] = block.hash
+
+        # Blocks still ordered by block height
+        blocktxs = [{"block": (i, blockhashes[i - 1])} for i in range(101, 0, -1)]
+        check_tx_history([], blocktxs)
+        check_tx_history([], blocktxs, page_size=200)
+
+        # Generate 900 more blocks and verify
+        # Total of 1001 txs for this script (a page in the DB is 1000 entries long)
+        blockhashes += self.generatetoaddress(node, 900, ADDRESS_ECREG_P2SH_OP_TRUE)
+        blocktxs = [{"block": (i, blockhashes[i - 1])} for i in range(1001, 0, -1)]
+        check_tx_history([], blocktxs, page_size=200)
+
+        coinvalue = 5000000000
+        cointxids = []
+        for coinblockhash in blockhashes[:100]:
+            coinblock = node.getblock(coinblockhash)
+            cointxids.append(coinblock["tx"][0])
+
+        mempool_txs = []
+        mempool_txids = []
+        # Send 10 mempool txs, each with their own mocktime
+        mocktime_offsets = [0, 10, 10, 5, 0, 0, 12, 12, 10, 5]
+        for mocktime_offset in mocktime_offsets:
+            cointxid = cointxids.pop(0)
+            tx = CTransaction()
+            tx.nVersion = 1
+            tx.vin = [
+                CTxIn(
+                    outpoint=COutPoint(int(cointxid, 16), 0),
+                    scriptSig=SCRIPTSIG_OP_TRUE,
+                )
+            ]
+            tx.vout = [CTxOut(coinvalue - 1000, P2SH_OP_TRUE)]
+            pad_tx(tx)
+            mempool_txs.append(tx)
+            node.setmocktime(mocktime + mocktime_offset)
+            txid = node.sendrawtransaction(tx.serialize().hex())
+            mempool_txids.append(txid)
+
+        def tx_sort_key(entry):
+            time_first_seen = entry["time_first_seen"]
+            txid = entry["txid"]
+            if time_first_seen == 0:
+                time_first_seen = 1 << 64
+            if entry.get("is_coinbase", False):
+                txid = ""
+            return (time_first_seen, txid)
+
+        mempooltxs = sorted(
+            [
+                {"time_first_seen": mocktime + offset, "txid": txid}
+                for (offset, txid) in zip(mocktime_offsets, mempool_txids)
+            ],
+            key=tx_sort_key,
+            reverse=True,
+        )
+        page_sizes = [1, 5, 7, 25, 111, 200]
+        for page_size in page_sizes:
+            check_tx_history(mempooltxs, blocktxs, page_size=page_size)
+
+        # Mine block with 5 conflicting txs
+        mine_txs = mempool_txs[5:]
+        newblocktxs = [
+            entry for entry in mempooltxs if entry["txid"] not in mempool_txids[:5]
+        ]
+        for idx, tx in enumerate(mempool_txs[:5]):
+            tx.nLockTime = 12
+            tx.rehash()
+            mine_txs.append(tx)
+            newblocktxs.append({"time_first_seen": 0, "txid": tx.hash})
+
+        height = 1002
+        coinbase_tx = create_coinbase(height)
+        coinbase_tx.vout[0].scriptPubKey = P2SH_OP_TRUE
+        coinbase_tx.rehash()
+        block = create_block(int(blockhashes[-1], 16), coinbase_tx, mocktime + 1100)
+        block.nVersion = 5
+        block.vtx += mine_txs
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        newblocktxs.append(
+            {"time_first_seen": 0, "txid": coinbase_tx.hash, "is_coinbase": True}
+        )
+
+        newblocktxs.sort(key=tx_sort_key, reverse=True)
+        for blocktx in newblocktxs:
+            blocktx["block"] = (height, block.hash)
+
+        check_tx_history([], newblocktxs + blocktxs, page_size=25)
+        check_tx_history([], newblocktxs + blocktxs, page_size=200)
+
+        # Order for different page sizes is not guaranteed within blocks.
+        txs_individually = [
+            chronik.script(script_type, payload_hex)
+            .history(page=i, page_size=1)
+            .ok()
+            .txs[0]
+            for i in range(20)
+        ]
+        txs_bulk = list(
+            chronik.script(script_type, payload_hex)
+            .history(page=0, page_size=20)
+            .ok()
+            .txs
+        )
+        # Contain the same txs, but not necessarily in the same order
+        assert_equal(
+            sorted(txs_individually, key=lambda tx: tx.txid),
+            sorted(txs_bulk, key=lambda tx: tx.txid),
+        )
+
+
+if __name__ == "__main__":
+    ChronikScriptHistoryTest().main()
diff --git a/test/functional/chronik_script_unconfirmed_txs.py b/test/functional/chronik_script_unconfirmed_txs.py
new file mode 100644
index 000000000..ff67f3a3b
--- /dev/null
+++ b/test/functional/chronik_script_unconfirmed_txs.py
@@ -0,0 +1,223 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /script/:type/:payload/unconfirmed-txs endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    GENESIS_CB_PK,
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_RETURN, CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikScriptUnconfirmedTxsTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        assert_equal(
+            chronik.script("", "").unconfirmed_txs().err(400).msg,
+            "400: Unknown script type: ",
+        )
+        assert_equal(
+            chronik.script(
+                "foo",
+                "",
+            )
+            .unconfirmed_txs()
+            .err(400)
+            .msg,
+            "400: Unknown script type: foo",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "LILALI").unconfirmed_txs().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("other", "LILALI").unconfirmed_txs().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script(
+                "p2pkh",
+                "",
+            )
+            .unconfirmed_txs()
+            .err(400)
+            .msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 0 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "aA").unconfirmed_txs().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 1 bytes",
+        )
+        assert_equal(
+            chronik.script("p2sh", "aaBB").unconfirmed_txs().err(400).msg,
+            "400: Invalid payload for P2SH: Invalid length, "
+            + "expected 20 bytes but got 2 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pk", "aaBBcc").unconfirmed_txs().err(400).msg,
+            "400: Invalid payload for P2PK: Invalid length, "
+            + "expected one of [33, 65] but got 3 bytes",
+        )
+
+        from test_framework.chronik.client import pb
+
+        # No txs in mempool for the genesis pubkey
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK).unconfirmed_txs().ok(),
+            pb.TxHistoryPage(num_pages=0, num_txs=0),
+        )
+
+        script_type = "p2sh"
+        payload_hex = P2SH_OP_TRUE[2:-1].hex()
+
+        # Generate 110 blocks to some address
+        blockhashes = self.generatetoaddress(node, 110, ADDRESS_ECREG_P2SH_OP_TRUE)
+
+        # No txs in mempool for that address
+        assert_equal(
+            chronik.script(script_type, payload_hex).unconfirmed_txs().ok(),
+            pb.TxHistoryPage(num_pages=0, num_txs=0),
+        )
+
+        coinvalue = 5000000000
+        cointxids = []
+        for coinblockhash in blockhashes[:10]:
+            coinblock = node.getblock(coinblockhash)
+            cointxids.append(coinblock["tx"][0])
+
+        mempool_txs = []
+        mempool_proto_txs = []
+        # Send 10 mempool txs, each with their own mocktime
+        mocktime_offsets = [0, 10, 10, 5, 0, 0, 12, 12, 10, 5]
+        for mocktime_offset in mocktime_offsets:
+            cointxid = cointxids.pop(0)
+            time_first_seen = mocktime + mocktime_offset
+            pad_script = CScript([OP_RETURN, bytes(100)])
+
+            tx = CTransaction()
+            tx.nVersion = 1
+            tx.vin = [
+                CTxIn(
+                    outpoint=COutPoint(int(cointxid, 16), 0),
+                    scriptSig=SCRIPTSIG_OP_TRUE,
+                    nSequence=0xFFFFFFFF,
+                )
+            ]
+            tx.vout = [
+                CTxOut(coinvalue - 1000, P2SH_OP_TRUE),
+                CTxOut(0, pad_script),
+            ]
+            tx.nLockTime = 1
+
+            node.setmocktime(time_first_seen)
+            txid = node.sendrawtransaction(tx.serialize().hex())
+            mempool_txs.append(tx)
+            mempool_proto_txs.append(
+                pb.Tx(
+                    txid=bytes.fromhex(txid)[::-1],
+                    version=1,
+                    inputs=[
+                        pb.TxInput(
+                            prev_out=pb.OutPoint(
+                                txid=bytes.fromhex(cointxid)[::-1],
+                                out_idx=0,
+                            ),
+                            input_script=bytes(SCRIPTSIG_OP_TRUE),
+                            output_script=bytes(P2SH_OP_TRUE),
+                            value=coinvalue,
+                            sequence_no=0xFFFFFFFF,
+                        )
+                    ],
+                    outputs=[
+                        pb.TxOutput(
+                            value=coinvalue - 1000,
+                            output_script=bytes(P2SH_OP_TRUE),
+                        ),
+                        pb.TxOutput(
+                            value=0,
+                            output_script=bytes(pad_script),
+                        ),
+                    ],
+                    lock_time=1,
+                    size=len(tx.serialize()),
+                    time_first_seen=time_first_seen,
+                )
+            )
+
+        # Sort txs by time_first_seen and then by txid
+        def sorted_txs(txs):
+            return sorted(txs, key=lambda tx: (tx.time_first_seen, tx.txid[::-1]))
+
+        assert_equal(
+            chronik.script(script_type, payload_hex).unconfirmed_txs().ok(),
+            pb.TxHistoryPage(
+                txs=sorted_txs(mempool_proto_txs), num_pages=1, num_txs=len(mempool_txs)
+            ),
+        )
+
+        # Mine 5 transactions, with 2 conflicts, leave 5 others unconfirmed
+        mine_txs = mempool_txs[:3]
+        mine_proto_txs = mempool_proto_txs[:3]
+        for conflict_tx, conflict_proto_tx in zip(
+            mempool_txs[3:5], mempool_proto_txs[3:5]
+        ):
+            conflict_tx.nLockTime = 2
+            conflict_tx.rehash()
+            mine_txs.append(conflict_tx)
+            conflict_proto_tx.txid = bytes.fromhex(conflict_tx.hash)[::-1]
+            conflict_proto_tx.lock_time = 2
+            mine_proto_txs.append(conflict_proto_tx)
+
+        height = 111
+        coinbase_tx = create_coinbase(height)
+        coinbase_tx.vout[0].scriptPubKey = P2SH_OP_TRUE
+        coinbase_tx.rehash()
+        block = create_block(int(blockhashes[-1], 16), coinbase_tx, mocktime + 1100)
+        block.vtx += mine_txs
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        # Only unconfirmed txs remain, conflict txs are removed
+        assert_equal(
+            chronik.script(script_type, payload_hex).unconfirmed_txs().ok(),
+            pb.TxHistoryPage(
+                txs=sorted_txs(mempool_proto_txs[5:]), num_pages=1, num_txs=5
+            ),
+        )
+
+
+if __name__ == "__main__":
+    ChronikScriptUnconfirmedTxsTest().main()
diff --git a/test/functional/chronik_script_utxos.py b/test/functional/chronik_script_utxos.py
new file mode 100644
index 000000000..50938c899
--- /dev/null
+++ b/test/functional/chronik_script_utxos.py
@@ -0,0 +1,253 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /script/:type/:payload/utxos endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    GENESIS_CB_PK,
+    GENESIS_CB_TXID,
+    create_block,
+    create_coinbase,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal
+
+
+class ChronikScriptUtxosTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        node.setmocktime(1300000000)
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        assert_equal(
+            chronik.script("", "").utxos().err(400).msg, "400: Unknown script type: "
+        )
+        assert_equal(
+            chronik.script("foo", "").utxos().err(400).msg,
+            "400: Unknown script type: foo",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "LILALI").utxos().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("other", "LILALI").utxos().err(400).msg,
+            "400: Invalid hex: Invalid character 'L' at position 0",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "").utxos().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 0 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pkh", "aA").utxos().err(400).msg,
+            "400: Invalid payload for P2PKH: Invalid length, "
+            + "expected 20 bytes but got 1 bytes",
+        )
+        assert_equal(
+            chronik.script("p2sh", "aaBB").utxos().err(400).msg,
+            "400: Invalid payload for P2SH: Invalid length, "
+            + "expected 20 bytes but got 2 bytes",
+        )
+        assert_equal(
+            chronik.script("p2pk", "aaBBcc").utxos().err(400).msg,
+            "400: Invalid payload for P2PK: Invalid length, "
+            + "expected one of [33, 65] but got 3 bytes",
+        )
+
+        from test_framework.chronik.client import pb
+
+        # Test Genesis pubkey UTXO
+        coinvalue = 5000000000
+        assert_equal(
+            chronik.script("p2pk", GENESIS_CB_PK).utxos().ok(),
+            pb.ScriptUtxos(
+                script=bytes.fromhex(f"41{GENESIS_CB_PK}ac"),
+                utxos=[
+                    pb.ScriptUtxo(
+                        outpoint=pb.OutPoint(
+                            txid=bytes.fromhex(GENESIS_CB_TXID)[::-1],
+                            out_idx=0,
+                        ),
+                        block_height=0,
+                        is_coinbase=True,
+                        value=coinvalue,
+                        is_final=False,
+                    )
+                ],
+            ),
+        )
+
+        script_type = "p2sh"
+        payload_hex = P2SH_OP_TRUE[2:-1].hex()
+
+        # Generate us a coin, creates a UTXO
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(
+                script=bytes(P2SH_OP_TRUE),
+                utxos=[
+                    pb.ScriptUtxo(
+                        outpoint=pb.OutPoint(
+                            txid=bytes.fromhex(cointx)[::-1],
+                            out_idx=0,
+                        ),
+                        block_height=1,
+                        is_coinbase=True,
+                        value=coinvalue,
+                        is_final=False,
+                    )
+                ],
+            ),
+        )
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        # Make tx creating 4 UTXOs, spending the coinbase UTXO
+        send_values = [coinvalue - 10000, 1000, 2000, 3000]
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(outpoint=COutPoint(int(cointx, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx.vout = [CTxOut(value, P2SH_OP_TRUE) for value in send_values]
+        txid = node.sendrawtransaction(tx.serialize().hex())
+
+        expected_utxos = [
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(txid)[::-1],
+                    out_idx=i,
+                ),
+                block_height=-1,
+                is_coinbase=False,
+                value=value,
+                is_final=False,
+            )
+            for i, value in enumerate(send_values)
+        ]
+
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(script=bytes(P2SH_OP_TRUE), utxos=expected_utxos),
+        )
+
+        # Mine tx, which adds the blockheight to the UTXO
+        tip = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[-1]
+        for expected_utxo in expected_utxos:
+            expected_utxo.block_height = 102
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(script=bytes(P2SH_OP_TRUE), utxos=expected_utxos),
+        )
+
+        # Make tx spending the 3rd UTXO, and creating 1 UTXO
+        tx2 = CTransaction()
+        tx2.vin = [
+            CTxIn(outpoint=COutPoint(int(txid, 16), 3), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx2.vout = [CTxOut(2500, P2SH_OP_TRUE)]
+        pad_tx(tx2)
+        txid2 = node.sendrawtransaction(tx2.serialize().hex())
+
+        del expected_utxos[3]
+        expected_utxos.append(
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(txid2)[::-1],
+                    out_idx=0,
+                ),
+                block_height=-1,
+                is_coinbase=False,
+                value=2500,
+                is_final=False,
+            )
+        )
+
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(script=bytes(P2SH_OP_TRUE), utxos=expected_utxos),
+        )
+
+        # Make tx spending a DB UTXO and a mempool UTXO
+        tx3 = CTransaction()
+        tx3.vin = [
+            CTxIn(outpoint=COutPoint(int(txid, 16), 2), scriptSig=SCRIPTSIG_OP_TRUE),
+            CTxIn(outpoint=COutPoint(int(txid2, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE),
+        ]
+        pad_tx(tx3)
+        node.sendrawtransaction(tx3.serialize().hex())
+
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(script=bytes(P2SH_OP_TRUE), utxos=expected_utxos[:2]),
+        )
+
+        # Make a tx which conflicts with tx3, by spending the same DB UTXO
+        tx3_conflict = CTransaction()
+        tx3_conflict.vin = [
+            CTxIn(outpoint=COutPoint(int(txid, 16), 2), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        pad_tx(tx3_conflict)
+
+        # Mining conflicting tx returns the mempool UTXO spent by tx3 to the mempool
+        block = create_block(
+            int(tip, 16), create_coinbase(103, b"\x03" * 33), 1300000500
+        )
+        block.vtx += [tx3_conflict]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        del expected_utxos[2]
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(script=bytes(P2SH_OP_TRUE), utxos=expected_utxos),
+        )
+
+        # Invalidating the last block doesn't change UTXOs
+        node.invalidateblock(block.hash)
+        assert_equal(
+            chronik.script(script_type, payload_hex).utxos().ok(),
+            pb.ScriptUtxos(script=bytes(P2SH_OP_TRUE), utxos=expected_utxos),
+        )
+
+        # Invalidating the next last block returns all UTXOs back to the mempool
+        node.invalidateblock(tip)
+        for expected_utxo in expected_utxos:
+            expected_utxo.block_height = -1
+
+        # Mempool UTXOs are sorted by txid:out_idx. Note: `sorted` is stable.
+        assert_equal(
+            list(chronik.script(script_type, payload_hex).utxos().ok().utxos),
+            sorted(expected_utxos, key=lambda utxo: utxo.outpoint.txid[::-1]),
+        )
+
+
+if __name__ == "__main__":
+    ChronikScriptUtxosTest().main()
diff --git a/test/functional/chronik_serve.py b/test/functional/chronik_serve.py
new file mode 100644
index 000000000..7c0b44637
--- /dev/null
+++ b/test/functional/chronik_serve.py
@@ -0,0 +1,70 @@
+# Copyright (c) 2022 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+import os
+
+from test_framework.netutil import test_ipv6_local
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, get_datadir_path
+
+
+class ChronikServeTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import DEFAULT_TIMEOUT, ChronikClient
+
+        def test_host(ip, port):
+            chronik = ChronikClient(
+                ip,
+                port,
+                timeout=DEFAULT_TIMEOUT,
+            )
+            response = chronik._request_get("/path/does/not/exist", pb_type=None)
+            assert_equal(response.err(404).msg, "404: Not found: /path/does/not/exist")
+
+        test_host("127.0.0.1", self.nodes[0].chronik_port)
+
+        datadir = get_datadir_path(self.options.tmpdir, 0)
+        config_path = os.path.join(datadir, "bitcoin.conf")
+        config_content = []
+        with open(config_path, "r", encoding="utf8") as f:
+            config_content = f.readlines()
+
+        os.unlink(config_path)
+
+        with open(config_path, "w", encoding="utf8") as f:
+            [
+                f.write(line)
+                for line in config_content
+                if not line.startswith("chronikbind")
+            ]
+
+        self.restart_node(0, ["-chronik", "-chronikbind=0.0.0.0"])
+        test_host("127.0.0.1", 18442)
+
+        self.restart_node(0, ["-chronik", "-chronikbind=127.0.0.1:12345"])
+        test_host("127.0.0.1", 12345)
+
+        if test_ipv6_local():
+            self.restart_node(
+                0,
+                [
+                    "-chronik",
+                    "-chronikbind=127.0.0.1:12345",
+                    "-chronikbind=[::1]:43456",
+                ],
+            )
+            test_host("127.0.0.1", 12345)
+            test_host("::1", 43456)
+
+
+if __name__ == "__main__":
+    ChronikServeTest().main()
diff --git a/test/functional/chronik_shutdown.py b/test/functional/chronik_shutdown.py
new file mode 100644
index 000000000..1de89878c
--- /dev/null
+++ b/test/functional/chronik_shutdown.py
@@ -0,0 +1,75 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test if Chronik properly shuts down.
+
+This tests a case where, when processing large blocks with lots of ins/outs, Chronik
+would lag behind. When shutting down at that moment, Chronik would continue to process
+blocks which, if we're not careful, might have been freed in the node already, resulting
+in a segfault.
+"""
+
+from test_framework.blocktools import (
+    GENESIS_BLOCK_HASH,
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut, msg_block
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_TRUE, CScript
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikShutdown(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        mocktime = 1300000000
+        node = self.nodes[0]
+        node.setmocktime(mocktime)
+        peer = node.add_p2p_connection(P2PDataStore())
+        self.wait_until(lambda: peer.is_connected, timeout=10)
+
+        last_block_hash = GENESIS_BLOCK_HASH
+        coinbase_txs = []
+        for i in range(1, 200):
+            coinbase_tx = create_coinbase(i)
+            coinbase_tx.vout[0].scriptPubKey = CScript([OP_TRUE])
+            coinbase_tx.rehash()
+            coinbase_txs.append(coinbase_tx)
+            block = create_block(int(last_block_hash, 16), coinbase_tx, mocktime + i)
+            if i > 101:
+                txid = coinbase_txs[i - 101].sha256
+                fan_tx = CTransaction()
+                fan_tx.vin = [CTxIn(COutPoint(txid, 0))]
+                fan_tx.vout = [CTxOut(1000, CScript([OP_TRUE]))] * 8000
+                fan_tx.rehash()
+                block.vtx.append(fan_tx)
+                for i in range(0, 7997, 3):
+                    tx = CTransaction()
+                    tx.vin = [
+                        CTxIn(COutPoint(fan_tx.sha256, j)) for j in range(i, i + 3)
+                    ]
+                    tx.vout = [CTxOut(1000, CScript([OP_TRUE]))]
+                    tx.rehash()
+                    block.vtx.append(tx)
+            make_conform_to_ctor(block)
+            block.hashMerkleRoot = block.calc_merkle_root()
+            block.solve()
+            last_block_hash = block.hash
+            peer.send_message(msg_block(block))
+
+        self.stop_nodes()
+
+
+if __name__ == "__main__":
+    ChronikShutdown().main()
diff --git a/test/functional/chronik_spent_by.py b/test/functional/chronik_spent_by.py
new file mode 100644
index 000000000..83a9c3b99
--- /dev/null
+++ b/test/functional/chronik_spent_by.py
@@ -0,0 +1,179 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test if the `Tx.spent_by` field is set correctly in Chronik.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_EQUAL, OP_HASH160, CScript, hash160
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal
+
+
+class ChronikSpentByTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        node.setmocktime(1300000000)
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        tip = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)[-1]
+
+        coinvalue = 5000000000
+        send_values = [coinvalue - 10000, 1000, 1000, 1000]
+        send_redeem_scripts = [bytes([i + 0x52]) for i in range(len(send_values))]
+        send_script_hashes = [hash160(script) for script in send_redeem_scripts]
+        send_scripts = [
+            CScript([OP_HASH160, script_hash, OP_EQUAL])
+            for script_hash in send_script_hashes
+        ]
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(outpoint=COutPoint(int(cointx, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx.vout = [
+            CTxOut(value, script) for (value, script) in zip(send_values, send_scripts)
+        ]
+        tx.rehash()
+
+        # Submit tx to mempool
+        txid = node.sendrawtransaction(tx.serialize().hex())
+
+        def tx_outputs_spent(tx):
+            return [output.spent_by for output in tx.outputs]
+
+        def find_tx(txs):
+            return [tx for tx in txs if tx.txid[::-1].hex() == txid][0]
+
+        def check_outputs_spent(expected_outpoints, *, has_been_mined):
+            assert_equal(
+                tx_outputs_spent(chronik.tx(txid).ok()),
+                expected_outpoints,
+            )
+            for script_hash in send_script_hashes:
+                chronik_script = chronik.script("p2sh", script_hash.hex())
+                if has_been_mined:
+                    txs = chronik_script.confirmed_txs().ok()
+                else:
+                    txs = chronik_script.unconfirmed_txs().ok()
+                tx = find_tx(txs.txs)
+                assert_equal(tx, find_tx(chronik_script.history().ok().txs))
+                assert_equal(
+                    tx_outputs_spent(tx),
+                    expected_outpoints,
+                )
+
+        from test_framework.chronik.client import pb
+
+        # Initially, none of the outputs are spent
+        check_outputs_spent([pb.SpentBy()] * len(send_values), has_been_mined=False)
+
+        # Add tx that spends the middle two outputs to mempool
+        tx2 = CTransaction()
+        tx2.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(txid, 16), i + 1),
+                scriptSig=CScript([redeem_script]),
+            )
+            for i, redeem_script in enumerate(send_redeem_scripts[1:3])
+        ]
+        pad_tx(tx2)
+        txid2 = node.sendrawtransaction(tx2.serialize().hex())
+
+        middle_two_spent = [
+            pb.SpentBy(),
+            pb.SpentBy(txid=bytes.fromhex(txid2)[::-1], input_idx=0),
+            pb.SpentBy(txid=bytes.fromhex(txid2)[::-1], input_idx=1),
+            pb.SpentBy(),
+        ]
+        check_outputs_spent(middle_two_spent, has_been_mined=False)
+
+        # Mining both txs still works
+        block2 = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        check_outputs_spent(middle_two_spent, has_been_mined=True)
+
+        # Add tx that also spends the last output to the mempool
+        tx3 = CTransaction()
+        tx3.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(txid, 16), 3),
+                scriptSig=CScript([send_redeem_scripts[3]]),
+            )
+        ]
+        pad_tx(tx3)
+        txid3 = node.sendrawtransaction(tx3.serialize().hex())
+
+        # 2 outputs spent by a mined tx, 1 output spent by a mempool tx
+        last_three_spent = [
+            pb.SpentBy(),
+            pb.SpentBy(txid=bytes.fromhex(txid2)[::-1], input_idx=0),
+            pb.SpentBy(txid=bytes.fromhex(txid2)[::-1], input_idx=1),
+            pb.SpentBy(txid=bytes.fromhex(txid3)[::-1], input_idx=0),
+        ]
+        check_outputs_spent(last_three_spent, has_been_mined=True)
+
+        # Mining tx3 still works
+        block3 = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        check_outputs_spent(last_three_spent, has_been_mined=True)
+
+        # Adding tx3 back to mempool still works
+        node.invalidateblock(block3)
+        check_outputs_spent(last_three_spent, has_been_mined=True)
+
+        # Adding tx and tx2 back to mempool still works
+        node.invalidateblock(block2)
+        check_outputs_spent(last_three_spent, has_been_mined=False)
+
+        # Mine a tx conflicting with tx3
+        tx3_conflict = CTransaction(tx3)
+        tx3_conflict.nLockTime = 1
+        tx3_conflict.rehash()
+
+        # Block mines tx, tx2 and tx3_conflict
+        block = create_block(
+            int(tip, 16), create_coinbase(102, b"\x03" * 33), 1300000500
+        )
+        block.vtx += [tx, tx2, tx3_conflict]
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        conflict_spent = [
+            pb.SpentBy(),
+            pb.SpentBy(txid=bytes.fromhex(txid2)[::-1], input_idx=0),
+            pb.SpentBy(txid=bytes.fromhex(txid2)[::-1], input_idx=1),
+            pb.SpentBy(txid=bytes.fromhex(tx3_conflict.hash)[::-1], input_idx=0),
+        ]
+        check_outputs_spent(conflict_spent, has_been_mined=True)
+
+
+if __name__ == "__main__":
+    ChronikSpentByTest().main()
diff --git a/test/functional/chronik_token_alp.py b/test/functional/chronik_token_alp.py
new file mode 100644
index 000000000..a4e4847bf
--- /dev/null
+++ b/test/functional/chronik_token_alp.py
@@ -0,0 +1,666 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's ALP integration.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.chronik.alp import (
+    alp_burn,
+    alp_genesis,
+    alp_mint,
+    alp_opreturn,
+    alp_send,
+)
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+
+
+class ChronikTokenAlp(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def alp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        block_hashes = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+        tx_names = []
+
+        # ALP GENESIS tx
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    token_ticker=b"TEST",
+                    token_name=b"Test Token",
+                    url=b"http://example.com",
+                    data=b"Token Data",
+                    auth_pubkey=b"Token Pubkey",
+                    decimals=4,
+                    mint_amounts=[10, 20, 30, 0],
+                    num_batons=2,
+                )
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+            CTxOut(5000, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=10),
+                alp_token(token_id=tx.hash, amount=20),
+                alp_token(token_id=tx.hash, amount=30),
+                pb.Token(),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(
+                    token_ticker=b"TEST",
+                    token_name=b"Test Token",
+                    url=b"http://example.com",
+                    data=b"Token Data",
+                    auth_pubkey=b"Token Pubkey",
+                    decimals=4,
+                ),
+            ),
+        )
+        txs.append(genesis)
+        tx_names.append("genesis")
+        genesis.send(chronik)
+        genesis.test(chronik)
+
+        # ALP MINT tx
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(genesis.txid, 16), 5),
+                SCRIPTSIG_OP_TRUE,
+            )
+        ]
+        tx.vout = [
+            alp_opreturn(
+                alp_mint(
+                    token_id=genesis.txid,
+                    mint_amounts=[5, 0],
+                    num_batons=1,
+                ),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        mint = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.MINT,
+                    actual_burn_amount="0",
+                )
+            ],
+            inputs=[alp_token(token_id=genesis.txid, is_mint_baton=True)],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=genesis.txid, amount=5),
+                pb.Token(),
+                alp_token(token_id=genesis.txid, is_mint_baton=True),
+            ],
+        )
+        txs.append(mint)
+        tx_names.append("mint")
+        mint.send(chronik)
+        mint.test(chronik)
+
+        # ALP SEND tx
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(genesis.txid, 16), 1),
+                SCRIPTSIG_OP_TRUE,
+            ),
+            CTxIn(COutPoint(int(mint.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+        ]
+        tx.vout = [
+            alp_opreturn(
+                alp_send(
+                    token_id=genesis.txid,
+                    output_amounts=[3, 12],
+                ),
+            ),
+            CTxOut(5000, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        send = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                )
+            ],
+            inputs=[
+                alp_token(token_id=genesis.txid, amount=10),
+                alp_token(token_id=genesis.txid, amount=5),
+            ],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=genesis.txid, amount=3),
+                alp_token(token_id=genesis.txid, amount=12),
+            ],
+        )
+        txs.append(send)
+        tx_names.append("send")
+        send.send(chronik)
+        send.test(chronik)
+
+        # Another ALP GENESIS
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(genesis.txid, 16), 4),
+                SCRIPTSIG_OP_TRUE,
+            )
+        ]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[100],
+                    num_batons=2,
+                ),
+            ),
+            CTxOut(5000, P2SH_OP_TRUE),
+            CTxOut(5000, P2SH_OP_TRUE),
+            CTxOut(5000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 200000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis2 = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=100),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis2)
+        tx_names.append("genesis2")
+        genesis2.send(chronik)
+        genesis2.test(chronik)
+
+        # ALP GENESIS + MINT + SEND all in one
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(COutPoint(int(send.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+            CTxIn(
+                COutPoint(int(genesis2.txid, 16), 2),
+                SCRIPTSIG_OP_TRUE,
+            ),
+        ]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    token_ticker=b"MULTI",
+                    mint_amounts=[0xFFFF_FFFF_FFFF, 0],
+                    num_batons=1,
+                ),
+                alp_mint(
+                    token_id=genesis2.txid,
+                    mint_amounts=[0, 5],
+                    num_batons=0,
+                ),
+                alp_burn(
+                    token_id=genesis.txid,
+                    burn_amount=1,
+                ),
+                alp_send(
+                    token_id=genesis.txid,
+                    output_amounts=[0, 0, 0, 0, 2],
+                ),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        multi = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id=genesis2.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.MINT,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    intentional_burn=1,
+                    actual_burn_amount="1",
+                ),
+            ],
+            inputs=[
+                alp_token(token_id=genesis.txid, amount=3, entry_idx=2),
+                alp_token(token_id=genesis2.txid, is_mint_baton=True, entry_idx=1),
+            ],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=0xFFFF_FFFF_FFFF),
+                alp_token(token_id=genesis2.txid, amount=5, entry_idx=1),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+                alp_token(token_id=genesis.txid, amount=2, entry_idx=2),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(token_ticker=b"MULTI"),
+            ),
+        )
+        txs.append(multi)
+        tx_names.append("multi")
+        multi.send(chronik)
+        multi.test(chronik)
+
+        # ALP tx with all kinds of things (so big it must be mined in a block manually)
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(genesis2.txid, 16), 3),
+                SCRIPTSIG_OP_TRUE,
+            ),
+            CTxIn(
+                COutPoint(int(genesis.txid, 16), 6),
+                SCRIPTSIG_OP_TRUE,
+            ),
+            CTxIn(COutPoint(int(multi.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+        ]
+        tx.vout = [
+            alp_opreturn(
+                # 0: success GENESIS
+                alp_genesis(
+                    token_ticker=b"ALL",
+                    mint_amounts=[0, 7, 0, 0, 1],
+                    num_batons=2,
+                ),
+                # 1: fail GENESIS: must be first
+                alp_genesis(mint_amounts=[], num_batons=0),
+                # 2: fail MINT: Too few outputs
+                alp_mint(genesis.txid, [0, 0, 0, 0, 0, 0, 0], 99),
+                # 3: fail MINT: Overlapping amounts
+                alp_mint(genesis.txid, [0, 0xFFFF_FFFF_FFFF], 0),
+                # 4: fail MINT: Overlapping batons
+                alp_mint(genesis.txid, [0], 1),
+                # 5: success BURN: token ID 2
+                alp_burn(genesis.txid, 2),
+                # 6: success MINT: token ID 3
+                alp_mint(genesis2.txid, [3, 0], 1),
+                # 7: success MINT: token ID 2
+                alp_mint(genesis.txid, [0, 0, 0, 2, 0, 0, 0], 1),
+                # 8: fail MINT: Duplicate token ID 2
+                alp_mint(genesis.txid, [], 0),
+                # 9: fail BURN: Duplicate burn token ID 2
+                alp_burn(genesis.txid, 0),
+                # 10: fail SEND: Too few outputs
+                alp_send(multi.txid, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123]),
+                # 11: success SEND: token ID 4
+                alp_send(
+                    multi.txid,
+                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFFFF_FFFF_FFFF],
+                ),
+                # 12: fail MINT: Duplicate token ID 4
+                alp_mint(multi.txid, [], 0),
+                # 13: success UNKNOWN
+                b"SLP2\x89",
+                # 14: fail BURN: Descending token type
+                alp_burn(multi.txid, 0),
+                # 15: success UNKNOWN
+                b"SLP2\x9a",
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(1000, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        all_things = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                    burn_summary="Invalid coloring at pushdata idx 1: GENESIS must be the first pushdata",
+                    failed_colorings=[
+                        pb.TokenFailedColoring(
+                            pushdata_idx=1,
+                            error="GENESIS must be the first pushdata",
+                        )
+                    ],
+                ),
+                pb.TokenEntry(
+                    token_id=genesis2.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.MINT,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.MINT,
+                    intentional_burn=2,
+                    actual_burn_amount="0",
+                    burn_summary=f"""\
+Invalid coloring at pushdata idx 2: Too few outputs, expected 107 but got 11. Invalid \
+coloring at pushdata idx 3: Overlapping amount when trying to color 281474976710655 at \
+index 2, output is already colored with 7 of {tx.hash} (ALP STANDARD (V0)). Invalid \
+coloring at pushdata idx 4: Overlapping mint baton when trying to color mint baton at \
+index 2, output is already colored with 7 of {tx.hash} (ALP STANDARD (V0)). Invalid \
+coloring at pushdata idx 8: Duplicate token_id {genesis.txid}, found in section 2. \
+Invalid coloring at pushdata idx 9: Duplicate intentional burn token_id \
+{genesis.txid}, found in burn #0 and #1""",
+                    failed_colorings=[
+                        pb.TokenFailedColoring(
+                            pushdata_idx=2,
+                            error="Too few outputs, expected 107 but got 11",
+                        ),
+                        pb.TokenFailedColoring(
+                            pushdata_idx=3,
+                            error=f"""\
+Overlapping amount when trying to color 281474976710655 at index 2, output is already \
+colored with 7 of {tx.hash} (ALP STANDARD (V0))""",
+                        ),
+                        pb.TokenFailedColoring(
+                            pushdata_idx=4,
+                            error=f"""\
+Overlapping mint baton when trying to color mint baton at index 2, output is already \
+colored with 7 of {tx.hash} (ALP STANDARD (V0))""",
+                        ),
+                        pb.TokenFailedColoring(
+                            pushdata_idx=8,
+                            error=f"Duplicate token_id {genesis.txid}, found in section 2",
+                        ),
+                        pb.TokenFailedColoring(
+                            pushdata_idx=9,
+                            error=f"Duplicate intentional burn token_id {genesis.txid}, found in burn #0 and #1",
+                        ),
+                    ],
+                ),
+                pb.TokenEntry(
+                    token_id=multi.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                    burn_summary=f"""\
+Invalid coloring at pushdata idx 10: Too few outputs, expected 13 but got 11. Invalid \
+coloring at pushdata idx 12: Duplicate token_id {multi.txid}, found in section 3. \
+Invalid coloring at pushdata idx 14: Descending token type: 137 > 0, token types must \
+be in ascending order""",
+                    failed_colorings=[
+                        pb.TokenFailedColoring(
+                            pushdata_idx=10,
+                            error="Too few outputs, expected 13 but got 11",
+                        ),
+                        pb.TokenFailedColoring(
+                            pushdata_idx=12,
+                            error=f"Duplicate token_id {multi.txid}, found in section 3",
+                        ),
+                        pb.TokenFailedColoring(
+                            pushdata_idx=14,
+                            error="Descending token type: 137 > 0, token types must be in ascending order",
+                        ),
+                    ],
+                ),
+                pb.TokenEntry(
+                    token_id="00" * 32,
+                    token_type=pb.TokenType(alp=0x89),
+                    tx_type=pb.UNKNOWN,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id="00" * 32,
+                    token_type=pb.TokenType(alp=0x9A),
+                    tx_type=pb.UNKNOWN,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[
+                alp_token(token_id=genesis2.txid, is_mint_baton=True, entry_idx=1),
+                alp_token(token_id=genesis.txid, is_mint_baton=True, entry_idx=2),
+                alp_token(token_id=multi.txid, amount=0xFFFF_FFFF_FFFF, entry_idx=3),
+            ],
+            outputs=[
+                pb.Token(),
+                # success MINT: token ID 3
+                alp_token(token_id=genesis2.txid, amount=3, entry_idx=1),
+                # success GENESIS
+                alp_token(token_id=tx.hash, amount=7),
+                # success MINT: token ID 3
+                alp_token(token_id=genesis2.txid, is_mint_baton=True, entry_idx=1),
+                # success MINT: token ID 2
+                alp_token(token_id=genesis.txid, amount=2, entry_idx=2),
+                # success GENESIS
+                alp_token(token_id=tx.hash, amount=1),
+                # success GENESIS
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                # success GENESIS
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                # success MINT: token ID 2
+                alp_token(token_id=genesis.txid, is_mint_baton=True, entry_idx=2),
+                # success UNKNOWN
+                alp_token(
+                    token_id="00" * 32, token_type=pb.TokenType(alp=0x89), entry_idx=4
+                ),
+                # success SEND: token ID 4
+                alp_token(
+                    token_id=multi.txid,
+                    amount=0xFFFF_FFFF_FFFF,
+                    entry_idx=3,
+                ),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(token_ticker=b"ALL"),
+            ),
+        )
+        block_height = 102
+        block = create_block(
+            int(block_hashes[-1], 16),
+            create_coinbase(block_height, b"\x03" * 33),
+            1300000500,
+        )
+        block.vtx += [
+            genesis.tx,
+            mint.tx,
+            send.tx,
+            genesis2.tx,
+            multi.tx,
+            all_things.tx,
+        ]
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        all_things.test(chronik, block.hash)
+
+        # After being mined, all previous txs still work fine:
+        for tx in txs:
+            tx.test(chronik, block.hash)
+
+        # Undo block + test again
+        node.invalidateblock(block.hash)
+        for tx in txs:
+            tx.test(chronik)
+
+        # "all_things" not in the mempool (violates policy)
+        chronik.tx(all_things.txid).err(404)
+
+        # Mining txs one-by-one works
+        block_height = 102
+        prev_hash = block_hashes[-1]
+        tx_block_hashes = [None] * len(txs)
+        for block_idx, mined_tx in enumerate(txs):
+            block = create_block(
+                int(prev_hash, 16),
+                create_coinbase(block_height + block_idx, b"\x03" * 33),
+                1300000500 + block_idx,
+            )
+            block.vtx += [mined_tx.tx]
+            block.hashMerkleRoot = block.calc_merkle_root()
+            block.solve()
+            prev_hash = block.hash
+            peer.send_blocks_and_test([block], node)
+            tx_block_hashes[block_idx] = block.hash
+
+            # All txs still work on every block
+            for tx, block_hash in zip(txs, tx_block_hashes):
+                tx.test(chronik, block_hash)
+
+        # Also mine all_things and test again
+        block = create_block(
+            int(prev_hash, 16),
+            create_coinbase(block_height + len(txs), b"\x03" * 33),
+            1300000500 + len(txs),
+        )
+        block.vtx += [all_things.tx]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        all_things.test(chronik, block.hash)
+        for tx, block_hash in zip(txs, tx_block_hashes):
+            tx.test(chronik, block_hash)
+
+        # Undo that block again + test
+        node.invalidateblock(block.hash)
+        for tx, block_hash in zip(txs, tx_block_hashes):
+            tx.test(chronik, block_hash)
+
+        # Invalidating all blocks one-by-one works
+        for block_idx in reversed(range(len(txs))):
+            node.invalidateblock(tx_block_hashes[block_idx])
+            tx_block_hashes[block_idx] = None
+            # All txs still work on every invalidation
+            for tx, block_hash in zip(txs, tx_block_hashes):
+                tx.test(chronik, block_hash)
+
+        # Kicking out all txs from the mempool by mining 1 conflict
+        conflict_tx = CTransaction()
+        conflict_tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        pad_tx(conflict_tx)
+        block = create_block(
+            int(block_hashes[-1], 16),
+            create_coinbase(block_height, b"\x03" * 33),
+            1300000500,
+        )
+        block.vtx += [conflict_tx]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        for tx in txs:
+            chronik.tx(tx.txid).err(404)
+
+
+if __name__ == "__main__":
+    ChronikTokenAlp().main()
diff --git a/test/functional/chronik_token_broadcast_txs.py b/test/functional/chronik_token_broadcast_txs.py
new file mode 100644
index 000000000..60f969f5b
--- /dev/null
+++ b/test/functional/chronik_token_broadcast_txs.py
@@ -0,0 +1,215 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik broadcasts a batch of txs correctly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.alp import alp_genesis, alp_opreturn, alp_send
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.script import CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikTokenBroadcastTxs(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def alp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[1000, 2000, 3000, 4000, 5000, 6000],
+                    num_batons=0,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=1000),
+                alp_token(token_id=tx.hash, amount=2000),
+                alp_token(token_id=tx.hash, amount=3000),
+                alp_token(token_id=tx.hash, amount=4000),
+                alp_token(token_id=tx.hash, amount=5000),
+                alp_token(token_id=tx.hash, amount=6000),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis)
+        genesis.send(chronik)
+        genesis.test(chronik)
+
+        ok_tx = CTransaction()
+        ok_tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        ok_tx.vout = [
+            alp_opreturn(alp_send(genesis.txid, [1000])),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        ok_tx.rehash()
+
+        burn_tx = CTransaction()
+        burn_tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 2), SCRIPTSIG_OP_TRUE)]
+        burn_tx.vout = [
+            alp_opreturn(alp_send(genesis.txid, [1999])),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        burn_tx.rehash()
+
+        burn2_tx = CTransaction()
+        burn2_tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 3), SCRIPTSIG_OP_TRUE)]
+        burn2_tx.vout = [
+            alp_opreturn(alp_send(genesis.txid, [3001])),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        burn2_tx.rehash()
+
+        wrong_sig_tx = CTransaction()
+        wrong_sig_tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 4), CScript())]
+        wrong_sig_tx.vout = [
+            alp_opreturn(alp_send(genesis.txid, [4000])),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        wrong_sig_tx.rehash()
+
+        ok2_tx = CTransaction()
+        ok2_tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 5), SCRIPTSIG_OP_TRUE)]
+        ok2_tx.vout = [
+            alp_opreturn(alp_send(genesis.txid, [5000])),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        ok2_tx.rehash()
+
+        ok3_tx = CTransaction()
+        ok3_tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 6), SCRIPTSIG_OP_TRUE)]
+        ok3_tx.vout = [
+            alp_opreturn(alp_send(genesis.txid, [6000])),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        ok3_tx.rehash()
+
+        error = chronik.broadcast_txs(
+            [
+                ok_tx.serialize(),
+                burn_tx.serialize(),
+                burn2_tx.serialize(),
+                wrong_sig_tx.serialize(),
+            ]
+        ).err(400)
+
+        assert_equal(
+            error.msg,
+            f"""\
+400: Tx {burn_tx.hash} failed token checks: Unexpected burn: Burns 1 base tokens. Tx \
+{burn2_tx.hash} failed token checks: Unexpected burn: Burns 3000 base tokens. \
+Reason(s): Insufficient token input output sum: 3000 < 3001.""",
+        )
+
+        # Token checks succeed but invalid sig -> broadcasts ok_tx anyway
+        error = chronik.broadcast_txs(
+            [
+                ok_tx.serialize(),
+                wrong_sig_tx.serialize(),
+                ok2_tx.serialize(),
+            ]
+        ).err(400)
+        assert_equal(
+            error.msg,
+            """\
+400: Broadcast failed: Transaction rejected by mempool: \
+mandatory-script-verify-flag-failed (Operation not valid with the current stack size)\
+""",
+        )
+        chronik.tx(ok_tx.hash).ok()
+        chronik.tx(ok2_tx.hash).err(404)
+
+        # Broadcast multiple txs successfully
+        txids = (
+            chronik.broadcast_txs(
+                [ok2_tx.serialize(), ok3_tx.serialize()],
+            )
+            .ok()
+            .txids
+        )
+        assert_equal(
+            txids,
+            [bytes.fromhex(ok2_tx.hash)[::-1], bytes.fromhex(ok3_tx.hash)[::-1]],
+        )
+
+        # Skip token checks, broadcast burns without complaining
+        txids = (
+            chronik.broadcast_txs(
+                [burn_tx.serialize(), burn2_tx.serialize()],
+                skip_token_checks=True,
+            )
+            .ok()
+            .txids
+        )
+        assert_equal(
+            txids,
+            [bytes.fromhex(burn_tx.hash)[::-1], bytes.fromhex(burn2_tx.hash)[::-1]],
+        )
+
+
+if __name__ == "__main__":
+    ChronikTokenBroadcastTxs().main()
diff --git a/test/functional/chronik_token_burn.py b/test/functional/chronik_token_burn.py
new file mode 100644
index 000000000..f2262a8d8
--- /dev/null
+++ b/test/functional/chronik_token_burn.py
@@ -0,0 +1,269 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes token burns correctly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.alp import alp_burn, alp_genesis, alp_opreturn, alp_send
+from test_framework.chronik.slp import slp_burn, slp_genesis
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikTokenBurn(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def slp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                **kwargs,
+            )
+
+        def alp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    mint_baton_vout=2,
+                    initial_mint_amount=5000,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_slp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                slp_token(token_id=tx.hash, amount=5000),
+                slp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_slp)
+        genesis_slp.send(chronik)
+        genesis_slp.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_slp.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_burn(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    token_id=genesis_slp.txid,
+                    amount=5000,
+                ),
+            ),
+        ]
+        burn_slp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis_slp.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.BURN,
+                    actual_burn_amount="5000",
+                    intentional_burn=5000,
+                ),
+            ],
+            inputs=[slp_token(token_id=genesis_slp.txid, amount=5000)],
+            outputs=[pb.Token()],
+        )
+        txs.append(burn_slp)
+        burn_slp.send(chronik)
+        burn_slp.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_slp.txid, 16), 3), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[1000],
+                    num_batons=1,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 200000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=1000),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_alp)
+        genesis_alp.send(chronik)
+        genesis_alp.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_alp.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_send(genesis_alp.txid, [400]),
+                alp_burn(genesis_alp.txid, 500),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        burn_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis_alp.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    burn_summary="Unexpected burn: Burns 600 base tokens, but intended to burn 500; burned 100 too many",
+                    actual_burn_amount="600",
+                    intentional_burn=500,
+                ),
+            ],
+            inputs=[alp_token(token_id=genesis_alp.txid, amount=1000)],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=genesis_alp.txid, amount=400),
+            ],
+        )
+        txs.append(burn_alp)
+        burn_alp.send(
+            chronik,
+            error=f"400: Tx {burn_alp.txid} failed token checks: Unexpected burn: Burns 600 base tokens, but intended to burn 500; burned 100 too many.",
+        )
+        burn_alp.test(chronik)
+
+        # Burns SLP mint baton + ALP tokens without any OP_RETURN
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(COutPoint(int(genesis_slp.txid, 16), 2), SCRIPTSIG_OP_TRUE),
+            CTxIn(COutPoint(int(burn_alp.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+        ]
+        tx.vout = [
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        bare_burn = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis_slp.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    is_invalid=True,
+                    burn_summary="Unexpected burn: Burns mint baton(s)",
+                    actual_burn_amount="0",
+                    burns_mint_batons=True,
+                ),
+                pb.TokenEntry(
+                    token_id=genesis_alp.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    is_invalid=True,
+                    burn_summary="Unexpected burn: Burns 400 base tokens",
+                    actual_burn_amount="400",
+                ),
+            ],
+            inputs=[
+                slp_token(token_id=genesis_slp.txid, is_mint_baton=True),
+                alp_token(token_id=genesis_alp.txid, amount=400, entry_idx=1),
+            ],
+            outputs=[
+                pb.Token(),
+            ],
+        )
+        txs.append(bare_burn)
+        bare_burn.send(
+            chronik,
+            error=f"400: Tx {bare_burn.txid} failed token checks: Unexpected burn: Burns mint baton(s). Unexpected burn: Burns 400 base tokens.",
+        )
+        bare_burn.test(chronik)
+
+        # After mining, all txs still work fine
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        for tx in txs:
+            tx.test(chronik, block_hash)
+
+        # Undo block + test again
+        node.invalidateblock(block_hash)
+        for tx in txs:
+            tx.test(chronik)
+
+
+if __name__ == "__main__":
+    ChronikTokenBurn().main()
diff --git a/test/functional/chronik_token_id_group.py b/test/functional/chronik_token_id_group.py
new file mode 100644
index 000000000..26792e9f3
--- /dev/null
+++ b/test/functional/chronik_token_id_group.py
@@ -0,0 +1,466 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes tx by token ID correctly.
+"""
+
+from itertools import zip_longest
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.alp import alp_genesis, alp_opreturn, alp_send
+from test_framework.chronik.slp import slp_genesis
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, chronik_sub_token_id
+
+
+class ChronikTokenBurn(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def slp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                **kwargs,
+            )
+
+        def alp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                **kwargs,
+            )
+
+        def ws_msg(txid: str, msg_type):
+            return pb.WsMsg(
+                tx=pb.MsgTx(
+                    msg_type=msg_type,
+                    txid=bytes.fromhex(txid)[::-1],
+                )
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+        ws1 = chronik.ws()
+        ws2 = chronik.ws()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    mint_baton_vout=2,
+                    initial_mint_amount=5000,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_slp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                slp_token(token_id=tx.hash, amount=5000),
+                slp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_slp)
+        chronik_sub_token_id(ws1, node, genesis_slp.txid)
+        genesis_slp.send(chronik)
+        genesis_slp.test(chronik)
+        assert_equal(ws1.recv(), ws_msg(genesis_slp.txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_slp.txid, 16), 3), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[1000, 2000],
+                    num_batons=1,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 200000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=1000),
+                alp_token(token_id=tx.hash, amount=2000),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_alp)
+        chronik_sub_token_id(ws1, node, genesis_alp.txid)
+        genesis_alp.send(chronik)
+        genesis_alp.test(chronik)
+        assert_equal(ws1.recv(), ws_msg(genesis_alp.txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_alp.txid, 16), 4), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[10, 20],
+                    num_batons=0,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 300000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis2_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=10),
+                alp_token(token_id=tx.hash, amount=20),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis2_alp)
+        chronik_sub_token_id(ws2, node, genesis2_alp.txid)
+        genesis2_alp.send(chronik)
+        genesis2_alp.test(chronik)
+        assert_equal(ws2.recv(), ws_msg(genesis2_alp.txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(COutPoint(int(genesis_slp.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+            CTxIn(COutPoint(int(genesis_alp.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+            CTxIn(COutPoint(int(genesis2_alp.txid, 16), 1), SCRIPTSIG_OP_TRUE),
+        ]
+        tx.vout = [
+            alp_opreturn(
+                alp_send(genesis_alp.txid, [400, 600]),
+                alp_send(genesis2_alp.txid, [0, 0, 3, 7]),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        send_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis_alp.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id=genesis2_alp.txid,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id=genesis_slp.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    is_invalid=True,
+                    burn_summary="Unexpected burn: Burns 5000 base tokens",
+                    actual_burn_amount="5000",
+                ),
+            ],
+            inputs=[
+                slp_token(token_id=genesis_slp.txid, amount=5000, entry_idx=2),
+                alp_token(token_id=genesis_alp.txid, amount=1000),
+                alp_token(token_id=genesis2_alp.txid, amount=10, entry_idx=1),
+            ],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=genesis_alp.txid, amount=400),
+                alp_token(token_id=genesis_alp.txid, amount=600),
+                alp_token(token_id=genesis2_alp.txid, amount=3, entry_idx=1),
+                alp_token(token_id=genesis2_alp.txid, amount=7, entry_idx=1),
+            ],
+        )
+        txs.append(send_alp)
+        send_alp.send(
+            chronik,
+            error=f"400: Tx {send_alp.txid} failed token checks: Unexpected burn: Burns 5000 base tokens.",
+        )
+        send_alp.test(chronik)
+        expected_msg = ws_msg(send_alp.txid, pb.TX_ADDED_TO_MEMPOOL)
+        assert_equal(ws1.recv(), expected_msg)
+        assert_equal(ws2.recv(), expected_msg)
+
+        slp_txs = sorted([genesis_slp, send_alp], key=lambda tx: tx.txid)
+        history_txs = chronik.token_id(genesis_slp.txid).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(slp_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        alp_txs = sorted([genesis_alp, send_alp], key=lambda tx: tx.txid)
+        history_txs = chronik.token_id(genesis_alp.txid).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(alp_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        alp2_txs = sorted([genesis2_alp, send_alp], key=lambda tx: tx.txid)
+        history_txs = chronik.token_id(genesis2_alp.txid).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(alp2_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        slp_utxos = [
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_slp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=10000,
+                script=bytes(P2SH_OP_TRUE),
+                token=slp_token(
+                    token_id=genesis_slp.txid, is_mint_baton=True, entry_idx=-1
+                ),
+            ),
+        ]
+        utxos = chronik.token_id(genesis_slp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(slp_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        alp_utxos = [
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_alp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=10000,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(token_id=genesis_alp.txid, amount=2000, entry_idx=-1),
+            ),
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_alp.txid)[::-1], out_idx=3
+                ),
+                block_height=-1,
+                value=10000,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(
+                    token_id=genesis_alp.txid, is_mint_baton=True, entry_idx=-1
+                ),
+            ),
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_alp.txid)[::-1], out_idx=1
+                ),
+                block_height=-1,
+                value=546,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(token_id=genesis_alp.txid, amount=400, entry_idx=-1),
+            ),
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_alp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=546,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(token_id=genesis_alp.txid, amount=600, entry_idx=-1),
+            ),
+        ]
+        alp_utxos = sorted(alp_utxos, key=lambda o: o.outpoint.txid[::-1])
+        utxos = chronik.token_id(genesis_alp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(alp_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        alp2_utxos = [
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis2_alp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=10000,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(token_id=genesis2_alp.txid, amount=20, entry_idx=-1),
+            ),
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_alp.txid)[::-1], out_idx=3
+                ),
+                block_height=-1,
+                value=546,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(token_id=genesis2_alp.txid, amount=3, entry_idx=-1),
+            ),
+            pb.Utxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_alp.txid)[::-1], out_idx=4
+                ),
+                block_height=-1,
+                value=546,
+                script=bytes(P2SH_OP_TRUE),
+                token=alp_token(token_id=genesis2_alp.txid, amount=7, entry_idx=-1),
+            ),
+        ]
+        alp2_utxos = sorted(alp2_utxos, key=lambda o: o.outpoint.txid[::-1])
+        utxos = chronik.token_id(genesis2_alp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(alp2_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        # Resubscribe so ws1=genesis_slp.txid, ws2=genesis_alp.txid, ws3=genesis2_alp.txid
+        chronik_sub_token_id(ws1, node, genesis_alp.txid, is_unsub=True)
+        chronik_sub_token_id(ws2, node, genesis2_alp.txid, is_unsub=True)
+        chronik_sub_token_id(ws2, node, genesis_alp.txid)
+        ws3 = chronik.ws()
+        chronik_sub_token_id(ws3, node, genesis2_alp.txid)
+
+        # After mining, all txs still work fine
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        for tx in txs:
+            tx.test(chronik, block_hash)
+
+        history_txs = chronik.token_id(genesis_slp.txid).confirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(slp_txs, history_txs):
+            tx.test_tx(proto_tx, block_hash)
+
+        history_txs = chronik.token_id(genesis_alp.txid).confirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(alp_txs, history_txs):
+            tx.test_tx(proto_tx, block_hash)
+
+        history_txs = chronik.token_id(genesis2_alp.txid).confirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(alp2_txs, history_txs):
+            tx.test_tx(proto_tx, block_hash)
+
+        for utxo in slp_utxos + alp_utxos + alp2_utxos:
+            utxo.block_height = 102
+
+        utxos = chronik.token_id(genesis_slp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(slp_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+        utxos = chronik.token_id(genesis_alp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(alp_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+        utxos = chronik.token_id(genesis2_alp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(alp2_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        for tx in slp_txs:
+            assert_equal(ws1.recv(), ws_msg(tx.txid, pb.TX_CONFIRMED))
+        for tx in alp_txs:
+            assert_equal(ws2.recv(), ws_msg(tx.txid, pb.TX_CONFIRMED))
+        for tx in alp2_txs:
+            assert_equal(ws3.recv(), ws_msg(tx.txid, pb.TX_CONFIRMED))
+
+        # Undo block + test again
+        node.invalidateblock(block_hash)
+        for tx in txs:
+            tx.test(chronik)
+
+        history_txs = chronik.token_id(genesis_slp.txid).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(slp_txs, history_txs):
+            tx.test_tx(proto_tx)
+        history_txs = chronik.token_id(genesis_alp.txid).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(alp_txs, history_txs):
+            tx.test_tx(proto_tx)
+        history_txs = chronik.token_id(genesis2_alp.txid).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(alp2_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        for utxo in slp_utxos + alp_utxos + alp2_utxos:
+            utxo.block_height = -1
+
+        utxos = chronik.token_id(genesis_slp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(slp_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+        utxos = chronik.token_id(genesis_alp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(alp_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+        utxos = chronik.token_id(genesis2_alp.txid).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(alp2_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        # TX_ADDED_TO_MEMPOOL are coming in topologically
+        for tx in [genesis_slp, send_alp]:
+            assert_equal(ws1.recv(), ws_msg(tx.txid, pb.TX_ADDED_TO_MEMPOOL))
+        for tx in [genesis_alp, send_alp]:
+            assert_equal(ws2.recv(), ws_msg(tx.txid, pb.TX_ADDED_TO_MEMPOOL))
+        for tx in [genesis2_alp, send_alp]:
+            assert_equal(ws3.recv(), ws_msg(tx.txid, pb.TX_ADDED_TO_MEMPOOL))
+
+
+if __name__ == "__main__":
+    ChronikTokenBurn().main()
diff --git a/test/functional/chronik_token_parse_failure.py b/test/functional/chronik_token_parse_failure.py
new file mode 100644
index 000000000..d4d2e247e
--- /dev/null
+++ b/test/functional/chronik_token_parse_failure.py
@@ -0,0 +1,129 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes parse failures correctly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.script import OP_RESERVED, OP_RETURN, CScript
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikTokenParseFailure(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        invalid_slp_script = CScript([OP_RETURN, b"SLP\0", b"\x01", b"GENESIS", b""])
+        tx.vout = [
+            CTxOut(0, invalid_slp_script),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        invalid_slp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[],
+            inputs=[pb.Token()],
+            outputs=[pb.Token(), pb.Token()],
+            failed_parsings=[
+                pb.TokenFailedParsing(
+                    pushdata_idx=-1,
+                    bytes=bytes(invalid_slp_script),
+                    error="SLP error: Disallowed push: OP_0 at op 4",
+                )
+            ],
+        )
+        txs.append(invalid_slp)
+        invalid_slp.send(
+            chronik,
+            error=f"400: Tx {invalid_slp.txid} failed token checks: Parsing failed: SLP error: Disallowed push: OP_0 at op 4.",
+        )
+        invalid_slp.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(invalid_slp.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        invalid_alp_script = CScript(
+            [OP_RETURN, OP_RESERVED, b"SLP2\0\x07GENESIS", b"OK", b"SLP\0"]
+        )
+        tx.vout = [
+            CTxOut(0, invalid_alp_script),
+            CTxOut(coinvalue - 200000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        invalid_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[],
+            inputs=[pb.Token()],
+            outputs=[pb.Token(), pb.Token()],
+            failed_parsings=[
+                pb.TokenFailedParsing(
+                    pushdata_idx=0,
+                    bytes=b"SLP2\0\x07GENESIS",
+                    error="ALP error: Not enough bytes: expected 1 more bytes but got 0 for field token_ticker",
+                ),
+                pb.TokenFailedParsing(
+                    pushdata_idx=2,
+                    bytes=b"SLP\0",
+                    error='ALP error: Invalid LOKAD ID "SLP\\0", did you accidentally use eMPP?',
+                ),
+            ],
+        )
+        txs.append(invalid_alp)
+        invalid_alp.send(
+            chronik,
+            error=f"""\
+400: Tx {invalid_alp.txid} failed token checks: Parsing failed at pushdata idx 0: ALP \
+error: Not enough bytes: expected 1 more bytes but got 0 for field token_ticker. \
+Parsing failed at pushdata idx 2: ALP error: Invalid LOKAD ID \"SLP\\0\", did you \
+accidentally use eMPP?.""",
+        )
+        invalid_alp.test(chronik)
+
+        # After mining, all txs still work fine
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        for tx in txs:
+            tx.test(chronik, block_hash)
+
+        # Undo block + test again
+        node.invalidateblock(block_hash)
+        for tx in txs:
+            tx.test(chronik)
+
+
+if __name__ == "__main__":
+    ChronikTokenParseFailure().main()
diff --git a/test/functional/chronik_token_script_group.py b/test/functional/chronik_token_script_group.py
new file mode 100644
index 000000000..a01c333a2
--- /dev/null
+++ b/test/functional/chronik_token_script_group.py
@@ -0,0 +1,330 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /script endpoint works well with tokens.
+"""
+
+from itertools import zip_longest
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.alp import alp_genesis, alp_opreturn
+from test_framework.chronik.slp import slp_genesis, slp_send
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.script import OP_EQUAL, OP_HASH160, CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikTokenScriptGroup(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def slp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                **kwargs,
+            )
+
+        def alp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    mint_baton_vout=2,
+                    initial_mint_amount=5000,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(546, CScript([OP_HASH160, b"\x01" * 20, OP_EQUAL])),
+            CTxOut(coinvalue - 100000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_slp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                slp_token(token_id=tx.hash, amount=5000),
+                slp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_slp)
+        genesis_slp.send(chronik)
+        genesis_slp.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_slp.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_send(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    token_id=genesis_slp.txid,
+                    amounts=[1000, 2000, 1500, 500],
+                ),
+            ),
+            CTxOut(546, CScript([OP_HASH160, b"\x01" * 20, OP_EQUAL])),
+            CTxOut(546, CScript([OP_HASH160, b"\x01" * 20, OP_EQUAL])),
+            CTxOut(546, CScript([OP_HASH160, b"\x02" * 20, OP_EQUAL])),
+            CTxOut(546, CScript([OP_HASH160, b"\x02" * 20, OP_EQUAL])),
+        ]
+        send_slp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis_slp.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[slp_token(token_id=genesis_slp.txid, amount=5000)],
+            outputs=[
+                pb.Token(),
+                slp_token(token_id=genesis_slp.txid, amount=1000),
+                slp_token(token_id=genesis_slp.txid, amount=2000),
+                slp_token(token_id=genesis_slp.txid, amount=1500),
+                slp_token(token_id=genesis_slp.txid, amount=500),
+            ],
+        )
+        txs.append(send_slp)
+        send_slp.send(chronik)
+        send_slp.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis_slp.txid, 16), 3), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            alp_opreturn(
+                alp_genesis(
+                    mint_amounts=[10, 20],
+                    num_batons=1,
+                ),
+            ),
+            CTxOut(546, CScript([OP_HASH160, b"\x01" * 20, OP_EQUAL])),
+            CTxOut(546, CScript([OP_HASH160, b"\x01" * 20, OP_EQUAL])),
+            CTxOut(546, CScript([OP_HASH160, b"\x01" * 20, OP_EQUAL])),
+            CTxOut(coinvalue - 200000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_alp = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                alp_token(token_id=tx.hash, amount=10),
+                alp_token(token_id=tx.hash, amount=20),
+                alp_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(alp=pb.ALP_TOKEN_TYPE_STANDARD),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_alp)
+        genesis_alp.send(chronik)
+        genesis_alp.test(chronik)
+
+        script1_txs = [genesis_slp, send_slp, genesis_alp]
+        script1_txs = sorted(script1_txs, key=lambda tx: tx.txid)
+        history_txs = chronik.script("p2sh", "01" * 20).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(script1_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        script2_txs = [send_slp]
+        history_txs = chronik.script("p2sh", "02" * 20).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(script2_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        script1_utxos = [
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_slp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=546,
+                token=slp_token(
+                    token_id=genesis_slp.txid, is_mint_baton=True, entry_idx=-1
+                ),
+            ),
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_slp.txid)[::-1], out_idx=1
+                ),
+                block_height=-1,
+                value=546,
+                token=slp_token(token_id=genesis_slp.txid, amount=1000, entry_idx=-1),
+            ),
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_slp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=546,
+                token=slp_token(token_id=genesis_slp.txid, amount=2000, entry_idx=-1),
+            ),
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_alp.txid)[::-1], out_idx=1
+                ),
+                block_height=-1,
+                value=546,
+                token=alp_token(token_id=genesis_alp.txid, amount=10, entry_idx=-1),
+            ),
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_alp.txid)[::-1], out_idx=2
+                ),
+                block_height=-1,
+                value=546,
+                token=alp_token(token_id=genesis_alp.txid, amount=20, entry_idx=-1),
+            ),
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(genesis_alp.txid)[::-1], out_idx=3
+                ),
+                block_height=-1,
+                value=546,
+                token=alp_token(
+                    token_id=genesis_alp.txid, is_mint_baton=True, entry_idx=-1
+                ),
+            ),
+        ]
+        script1_utxos = sorted(script1_utxos, key=lambda o: o.outpoint.txid[::-1])
+        utxos = chronik.script("p2sh", "01" * 20).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(script1_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        script2_utxos = [
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_slp.txid)[::-1], out_idx=3
+                ),
+                block_height=-1,
+                value=546,
+                token=slp_token(token_id=genesis_slp.txid, amount=1500, entry_idx=-1),
+            ),
+            pb.ScriptUtxo(
+                outpoint=pb.OutPoint(
+                    txid=bytes.fromhex(send_slp.txid)[::-1], out_idx=4
+                ),
+                block_height=-1,
+                value=546,
+                token=slp_token(token_id=genesis_slp.txid, amount=500, entry_idx=-1),
+            ),
+        ]
+        script2_utxos = sorted(script2_utxos, key=lambda o: o.outpoint.txid[::-1])
+        utxos = chronik.script("p2sh", "02" * 20).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(script2_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        # After mining, all txs still work fine
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        for tx in txs:
+            tx.test(chronik, block_hash)
+
+        history_txs = chronik.script("p2sh", "01" * 20).confirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(script1_txs, history_txs):
+            tx.test_tx(proto_tx, block_hash)
+        history_txs = chronik.script("p2sh", "02" * 20).confirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(script2_txs, history_txs):
+            tx.test_tx(proto_tx, block_hash)
+
+        for utxo in script1_utxos + script2_utxos:
+            utxo.block_height = 102
+        utxos = chronik.script("p2sh", "01" * 20).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(script1_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+        utxos = chronik.script("p2sh", "02" * 20).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(script2_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+        # Undo block + test again
+        node.invalidateblock(block_hash)
+        for tx in txs:
+            tx.test(chronik)
+
+        history_txs = chronik.script("p2sh", "01" * 20).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(script1_txs, history_txs):
+            tx.test_tx(proto_tx)
+        history_txs = chronik.script("p2sh", "02" * 20).unconfirmed_txs().ok().txs
+        for tx, proto_tx in zip_longest(script2_txs, history_txs):
+            tx.test_tx(proto_tx)
+
+        for utxo in script1_utxos + script2_utxos:
+            utxo.block_height = -1
+        utxos = chronik.script("p2sh", "01" * 20).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(script1_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+        utxos = chronik.script("p2sh", "02" * 20).utxos().ok().utxos
+        for utxo, proto_utxo in zip_longest(script2_utxos, utxos):
+            assert_equal(utxo, proto_utxo)
+
+
+if __name__ == "__main__":
+    ChronikTokenScriptGroup().main()
diff --git a/test/functional/chronik_token_slp_fungible.py b/test/functional/chronik_token_slp_fungible.py
new file mode 100644
index 000000000..0f1f46c35
--- /dev/null
+++ b/test/functional/chronik_token_slp_fungible.py
@@ -0,0 +1,247 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes fungible SLP tokens.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.slp import slp_genesis, slp_mint, slp_send
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikTokenSlpFungible(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def slp_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    token_ticker=b"SLPTEST",
+                    token_name=b"Test SLP Token 3",
+                    token_document_url=b"http://example/slp",
+                    token_document_hash=b"x" * 32,
+                    decimals=4,
+                    mint_baton_vout=2,
+                    initial_mint_amount=5000,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 400000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                pb.Token(
+                    token_id=tx.hash,
+                    amount=5000,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                ),
+                pb.Token(
+                    token_id=tx.hash,
+                    is_mint_baton=True,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                ),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                genesis_info=pb.GenesisInfo(
+                    token_ticker=b"SLPTEST",
+                    token_name=b"Test SLP Token 3",
+                    url=b"http://example/slp",
+                    hash=b"x" * 32,
+                    decimals=4,
+                ),
+            ),
+        )
+        txs.append(genesis)
+        genesis.send(chronik)
+        genesis.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 2), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_mint(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    token_id=genesis.txid,
+                    mint_baton_vout=3,
+                    mint_amount=20,
+                ),
+            ),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+        ]
+        mint = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.MINT,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[slp_token(token_id=genesis.txid, is_mint_baton=True)],
+            outputs=[
+                pb.Token(),
+                slp_token(token_id=genesis.txid, amount=20),
+                pb.Token(),
+                slp_token(token_id=genesis.txid, is_mint_baton=True),
+            ],
+        )
+        txs.append(mint)
+        mint.send(chronik)
+        mint.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_send(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    token_id=genesis.txid,
+                    amounts=[1000, 4000],
+                ),
+            ),
+            CTxOut(4000, P2SH_OP_TRUE),
+            CTxOut(4000, P2SH_OP_TRUE),
+        ]
+        send = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[
+                slp_token(token_id=genesis.txid, amount=5000),
+            ],
+            outputs=[
+                pb.Token(),
+                slp_token(token_id=genesis.txid, amount=1000),
+                slp_token(token_id=genesis.txid, amount=4000),
+            ],
+        )
+        txs.append(send)
+        send.send(chronik)
+        send.test(chronik)
+
+        # SLP GENESIS with empty GenesisInfo
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 3), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_FUNGIBLE,
+                    mint_baton_vout=None,
+                    initial_mint_amount=0,
+                ),
+            ),
+            CTxOut(coinvalue - 500000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis_empty = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_FUNGIBLE),
+                genesis_info=pb.GenesisInfo(),
+            ),
+        )
+        txs.append(genesis_empty)
+        genesis_empty.send(chronik)
+        genesis_empty.test(chronik)
+
+        # After mining, all txs still work fine
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        for tx in txs:
+            tx.test(chronik, block_hash)
+
+        # Undo block + test again
+        node.invalidateblock(block_hash)
+        for tx in txs:
+            tx.test(chronik)
+
+
+if __name__ == "__main__":
+    ChronikTokenSlpFungible().main()
diff --git a/test/functional/chronik_token_slp_mint_vault.py b/test/functional/chronik_token_slp_mint_vault.py
new file mode 100644
index 000000000..78b62c195
--- /dev/null
+++ b/test/functional/chronik_token_slp_mint_vault.py
@@ -0,0 +1,349 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes SLP V2 MINT VAULT txs correctly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import (
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.chronik.slp import slp_genesis, slp_mint_vault, slp_send
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_12, OP_EQUAL, OP_HASH160, CScript, hash160
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+
+
+class ChronikTokenSlpMintVault(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def vault_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_MINT_VAULT),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        block_hashes = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        # Fan-out UTXOs so we have coins to work with
+        fan_tx = CTransaction()
+        fan_tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        fan_tx.vout = [
+            CTxOut(100000, P2SH_OP_TRUE),
+            CTxOut(100000, P2SH_OP_TRUE),
+            CTxOut(100000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 500000, P2SH_OP_TRUE),
+        ]
+        fan_tx.rehash()
+        fan_txid = node.sendrawtransaction(fan_tx.serialize().hex())
+
+        # VAULT script locking MINT txs
+        mint_vault_script = CScript([OP_12])
+        mint_vault_scripthash = hash160(mint_vault_script)
+
+        # Setup vault UTXOs
+        vault_setup_tx = CTransaction()
+        vault_setup_tx.vin = [CTxIn(COutPoint(int(fan_txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        vault_setup_tx.vout = [
+            CTxOut(10000, CScript([OP_HASH160, mint_vault_scripthash, OP_EQUAL])),
+            CTxOut(10000, CScript([OP_HASH160, mint_vault_scripthash, OP_EQUAL])),
+            CTxOut(79000, CScript([OP_HASH160, mint_vault_scripthash, OP_EQUAL])),
+        ]
+        pad_tx(vault_setup_tx)
+        vault_setup_txid = node.sendrawtransaction(vault_setup_tx.serialize().hex())
+        # Mine VAULT setup txs
+        block_hashes += self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)
+
+        # SLP V2 MINT VAULT GENESIS
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(fan_txid, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_MINT_VAULT,
+                    token_ticker=b"SLPVAULT",
+                    token_name=b"0",
+                    token_document_url=b"0",
+                    token_document_hash=b"x" * 32,
+                    mint_vault_scripthash=mint_vault_scripthash,
+                    initial_mint_amount=1000,
+                ),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(99000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_MINT_VAULT),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                vault_token(token_id=tx.hash, amount=1000),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_MINT_VAULT),
+                genesis_info=pb.GenesisInfo(
+                    token_ticker=b"SLPVAULT",
+                    token_name=b"0",
+                    url=b"0",
+                    hash=b"x" * 32,
+                    mint_vault_scripthash=mint_vault_scripthash,
+                ),
+            ),
+        )
+        genesis.send(chronik)
+        genesis.test(chronik)
+
+        # SLP V2 MINT VAULT MINT
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(vault_setup_txid, 16), 0),
+                CScript([bytes(CScript([OP_12]))]),
+            )
+        ]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_mint_vault(
+                    token_id=genesis.txid,
+                    mint_amounts=[4000],
+                ),
+            ),
+            CTxOut(9000, P2SH_OP_TRUE),
+        ]
+        # MINT tx, but invalid because the GENESIS tx isn't mined yet
+        mint = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_MINT_VAULT),
+                    tx_type=pb.MINT,
+                    is_invalid=True,
+                    burn_summary="Validation error: Missing MINT vault",
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                pb.Token(),
+            ],
+        )
+        mint.send(
+            chronik,
+            error=f"400: Tx {mint.txid} failed token checks: Validation error: Missing MINT vault.",
+        )
+        mint.test(chronik)
+
+        # Mine only the GENESIS tx
+        block_height = 103
+        block = create_block(
+            int(block_hashes[-1], 16),
+            create_coinbase(block_height, b"\x03" * 33),
+            1300000500,
+        )
+        block.vtx += [genesis.tx]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        genesis.test(chronik, block.hash)
+
+        # MINT is still invalid, despite GENESIS being mined.
+        # This inconsistency is intended behavior, see chronik/chronik-db/src/mem/tokens.rs for details.
+        mint.test(chronik)
+
+        # Another SLP V2 MINT VAULT MINT, this time valid because the GENESIS is mined.
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(vault_setup_txid, 16), 1),
+                CScript([bytes(CScript([OP_12]))]),
+            )
+        ]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_mint_vault(
+                    token_id=genesis.txid,
+                    mint_amounts=[5000],
+                ),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        mint2 = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_MINT_VAULT),
+                    tx_type=pb.MINT,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                vault_token(token_id=genesis.txid, amount=5000),
+            ],
+        )
+        mint2.send(chronik)
+        mint2.test(chronik)
+
+        # Reorg block with the GENESIS tx
+        node.invalidateblock(block.hash)
+
+        # GENESIS still valid
+        genesis.test(chronik)
+        # MINT still invalid (correctly, now)
+        mint.test(chronik)
+
+        # mint2 now invalid (disconnect removes and re-adds all mempool txs)
+        mint2.status = pb.TOKEN_STATUS_NOT_NORMAL
+        mint2.entries[0].is_invalid = True
+        mint2.entries[0].burn_summary = "Validation error: Missing MINT vault"
+        mint2.outputs = [pb.Token(), pb.Token()]
+        mint2.test(chronik)
+
+        # Mine GENESIS and mint2
+        block_height = 103
+        block = create_block(
+            int(block_hashes[-1], 16),
+            create_coinbase(block_height, b"\x03" * 33),
+            1300000500,
+        )
+        block.vtx += [genesis.tx, mint2.tx]
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+        block_hashes.append(block.hash)
+
+        # GENESIS still valid
+        genesis.test(chronik, block.hash)
+        # MINTs still invalid
+        mint.test(chronik)
+        mint2.test(chronik, block.hash)
+
+        # Add SEND to mempool from `mint`
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(
+                COutPoint(int(mint.txid, 16), 1),
+                SCRIPTSIG_OP_TRUE,
+            )
+        ]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_send(
+                    token_type=pb.SLP_TOKEN_TYPE_MINT_VAULT,
+                    token_id=genesis.txid,
+                    amounts=[3000, 1000],
+                ),
+            ),
+            CTxOut(546, P2SH_OP_TRUE),
+            CTxOut(546, P2SH_OP_TRUE),
+        ]
+        send = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NOT_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_MINT_VAULT),
+                    tx_type=pb.SEND,
+                    is_invalid=True,
+                    actual_burn_amount="0",
+                    burn_summary="Validation error: Insufficient token input output sum: 0 < 4000",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                pb.Token(),
+                pb.Token(),
+            ],
+        )
+        send.send(
+            chronik,
+            error=f"400: Tx {send.txid} failed token checks: Validation error: Insufficient token input output sum: 0 < 4000.",
+        )
+        send.test(chronik)
+
+        # Mine mint
+        block_hashes += self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)
+        # Now it becomes valid
+        mint.status = pb.TOKEN_STATUS_NORMAL
+        mint.entries[0].is_invalid = False
+        mint.entries[0].burn_summary = ""
+        mint.outputs = [pb.Token(), vault_token(token_id=genesis.txid, amount=4000)]
+        mint.test(chronik, block_hashes[-1])
+        # The SEND also transitively becomes valid
+        send.status = pb.TOKEN_STATUS_NORMAL
+        send.entries[0].is_invalid = False
+        send.entries[0].burn_summary = ""
+        send.inputs = [vault_token(token_id=genesis.txid, amount=4000)]
+        send.outputs = [
+            pb.Token(),
+            vault_token(token_id=genesis.txid, amount=3000),
+            vault_token(token_id=genesis.txid, amount=1000),
+        ]
+        send.test(chronik, block_hashes[-1])
+
+        # After invalidating the last block, the txs are still valid
+        node.invalidateblock(block_hashes[-1])
+        mint.test(chronik)
+        send.test(chronik)
+
+
+if __name__ == "__main__":
+    ChronikTokenSlpMintVault().main()
diff --git a/test/functional/chronik_token_slp_nft1.py b/test/functional/chronik_token_slp_nft1.py
new file mode 100644
index 000000000..5f3c404d3
--- /dev/null
+++ b/test/functional/chronik_token_slp_nft1.py
@@ -0,0 +1,260 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik indexes SLP NFT1 tokens correctly.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.chronik.slp import slp_genesis, slp_mint, slp_send
+from test_framework.chronik.token_tx import TokenTx
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.test_framework import BitcoinTestFramework
+
+
+class ChronikTokenSlpNft1(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        def group_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_GROUP),
+                **kwargs,
+            )
+
+        def child_token(token_type=None, **kwargs) -> pb.Token:
+            return pb.Token(
+                token_type=token_type or pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_CHILD),
+                **kwargs,
+            )
+
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+
+        txs = []
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(cointx, 16), 0), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_NFT1_GROUP,
+                    token_ticker=b"SLP NFT GROUP",
+                    token_name=b"Slp NFT GROUP token",
+                    token_document_url=b"http://slp.nft",
+                    token_document_hash=b"x" * 32,
+                    decimals=4,
+                    mint_baton_vout=2,
+                    initial_mint_amount=5000,
+                ),
+            ),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(10000, P2SH_OP_TRUE),
+            CTxOut(coinvalue - 400000, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        genesis = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_GROUP),
+                    tx_type=pb.GENESIS,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[pb.Token()],
+            outputs=[
+                pb.Token(),
+                group_token(token_id=tx.hash, amount=5000),
+                group_token(token_id=tx.hash, is_mint_baton=True),
+                pb.Token(),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_GROUP),
+                genesis_info=pb.GenesisInfo(
+                    token_ticker=b"SLP NFT GROUP",
+                    token_name=b"Slp NFT GROUP token",
+                    url=b"http://slp.nft",
+                    hash=b"x" * 32,
+                    decimals=4,
+                ),
+            ),
+        )
+        txs.append(genesis)
+        genesis.send(chronik)
+        genesis.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 2), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_mint(
+                    token_type=pb.SLP_TOKEN_TYPE_NFT1_GROUP,
+                    token_id=genesis.txid,
+                    mint_baton_vout=3,
+                    mint_amount=20,
+                ),
+            ),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+        ]
+        mint = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_GROUP),
+                    tx_type=pb.MINT,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[group_token(token_id=genesis.txid, is_mint_baton=True)],
+            outputs=[
+                pb.Token(),
+                group_token(token_id=genesis.txid, amount=20),
+                pb.Token(),
+                group_token(token_id=genesis.txid, is_mint_baton=True),
+            ],
+        )
+        txs.append(mint)
+        mint.send(chronik)
+        mint.test(chronik)
+
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(genesis.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_send(
+                    token_type=pb.SLP_TOKEN_TYPE_NFT1_GROUP,
+                    token_id=genesis.txid,
+                    amounts=[1, 99, 900, 4000],
+                ),
+            ),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+            CTxOut(2000, P2SH_OP_TRUE),
+        ]
+        send = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_GROUP),
+                    tx_type=pb.SEND,
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[
+                group_token(token_id=genesis.txid, amount=5000),
+            ],
+            outputs=[
+                pb.Token(),
+                group_token(token_id=genesis.txid, amount=1),
+                group_token(token_id=genesis.txid, amount=99),
+                group_token(token_id=genesis.txid, amount=900),
+                group_token(token_id=genesis.txid, amount=4000),
+            ],
+        )
+        txs.append(send)
+        send.send(chronik)
+        send.test(chronik)
+
+        # NFT1 CHILD GENESIS
+        tx = CTransaction()
+        tx.vin = [CTxIn(COutPoint(int(send.txid, 16), 1), SCRIPTSIG_OP_TRUE)]
+        tx.vout = [
+            CTxOut(
+                0,
+                slp_genesis(
+                    token_type=pb.SLP_TOKEN_TYPE_NFT1_CHILD,
+                    token_ticker=b"SLP NFT CHILD",
+                    token_name=b"Slp NFT CHILD token",
+                    decimals=0,
+                    initial_mint_amount=1,
+                ),
+            ),
+            CTxOut(1400, P2SH_OP_TRUE),
+        ]
+        tx.rehash()
+        child_genesis1 = TokenTx(
+            tx=tx,
+            status=pb.TOKEN_STATUS_NORMAL,
+            entries=[
+                pb.TokenEntry(
+                    token_id=tx.hash,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_CHILD),
+                    tx_type=pb.GENESIS,
+                    group_token_id=genesis.txid,
+                    actual_burn_amount="0",
+                ),
+                pb.TokenEntry(
+                    token_id=genesis.txid,
+                    token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_GROUP),
+                    actual_burn_amount="0",
+                ),
+            ],
+            inputs=[group_token(token_id=genesis.txid, entry_idx=1, amount=1)],
+            outputs=[
+                pb.Token(),
+                child_token(token_id=tx.hash, amount=1),
+            ],
+            token_info=pb.TokenInfo(
+                token_id=tx.hash,
+                token_type=pb.TokenType(slp=pb.SLP_TOKEN_TYPE_NFT1_CHILD),
+                genesis_info=pb.GenesisInfo(
+                    token_ticker=b"SLP NFT CHILD",
+                    token_name=b"Slp NFT CHILD token",
+                ),
+            ),
+        )
+        txs.append(child_genesis1)
+        child_genesis1.send(chronik)
+        child_genesis1.test(chronik)
+
+        # After mining, all txs still work fine
+        block_hash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        for tx in txs:
+            tx.test(chronik, block_hash)
+
+        # Undo block + test again
+        node.invalidateblock(block_hash)
+        for tx in txs:
+            tx.test(chronik)
+
+
+if __name__ == "__main__":
+    ChronikTokenSlpNft1().main()
diff --git a/test/functional/chronik_tx.py b/test/functional/chronik_tx.py
new file mode 100644
index 000000000..d698225ec
--- /dev/null
+++ b/test/functional/chronik_tx.py
@@ -0,0 +1,214 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik's /tx endpoint.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.blocktools import GENESIS_CB_TXID, create_block, create_coinbase
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_EQUAL, OP_HASH160, CScript, hash160
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal
+
+
+class ChronikTxTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        peer = node.add_p2p_connection(P2PDataStore())
+        node.setmocktime(1333333337)
+
+        assert_equal(chronik.tx("0").err(400).msg, "400: Not a txid: 0")
+        assert_equal(chronik.tx("123").err(400).msg, "400: Not a txid: 123")
+        assert_equal(chronik.tx("1234f").err(400).msg, "400: Not a txid: 1234f")
+        assert_equal(chronik.tx("00" * 31).err(400).msg, f'400: Not a txid: {"00"*31}')
+        assert_equal(chronik.tx("01").err(400).msg, "400: Not a txid: 01")
+        assert_equal(
+            chronik.tx("12345678901").err(400).msg, "400: Not a txid: 12345678901"
+        )
+
+        assert_equal(
+            chronik.tx("00" * 32).err(404).msg,
+            f'404: Transaction {"00"*32} not found in the index',
+        )
+
+        from test_framework.chronik.test_data import genesis_cb_tx
+
+        # Verify queried genesis tx matches
+        assert_equal(chronik.tx(GENESIS_CB_TXID).ok(), genesis_cb_tx())
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+        send_values = [coinvalue - 10000, 1000, 2000, 3000]
+        send_redeem_scripts = [bytes([i + 0x52]) for i in range(len(send_values))]
+        send_scripts = [
+            CScript([OP_HASH160, hash160(redeem_script), OP_EQUAL])
+            for redeem_script in send_redeem_scripts
+        ]
+        tx = CTransaction()
+        tx.nVersion = 2
+        tx.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(cointx, 16), 0),
+                scriptSig=SCRIPTSIG_OP_TRUE,
+                nSequence=0xFFFFFFFE,
+            )
+        ]
+        tx.vout = [
+            CTxOut(value, script) for (value, script) in zip(send_values, send_scripts)
+        ]
+        tx.nLockTime = 1234567890
+
+        # Submit tx to mempool
+        txid = node.sendrawtransaction(tx.serialize().hex())
+
+        from test_framework.chronik.client import pb
+
+        proto_tx = pb.Tx(
+            txid=bytes.fromhex(txid)[::-1],
+            version=tx.nVersion,
+            inputs=[
+                pb.TxInput(
+                    prev_out=pb.OutPoint(txid=bytes.fromhex(cointx)[::-1], out_idx=0),
+                    input_script=bytes(tx.vin[0].scriptSig),
+                    output_script=bytes(P2SH_OP_TRUE),
+                    value=coinvalue,
+                    sequence_no=0xFFFFFFFE,
+                )
+            ],
+            outputs=[
+                pb.TxOutput(
+                    value=value,
+                    output_script=bytes(script),
+                )
+                for value, script in zip(send_values, send_scripts)
+            ],
+            lock_time=1234567890,
+            block=None,
+            time_first_seen=1333333337,
+            size=len(tx.serialize()),
+            is_coinbase=False,
+        )
+
+        assert_equal(chronik.tx(txid).ok(), proto_tx)
+
+        # If we mine the block, querying will gives us all the tx details + block
+        txblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+
+        # Set the `block` field, now that we mined it
+        proto_tx.block.CopyFrom(
+            pb.BlockMetadata(
+                hash=bytes.fromhex(txblockhash)[::-1],
+                height=102,
+                timestamp=1333333355,
+            )
+        )
+        assert_equal(chronik.tx(txid).ok(), proto_tx)
+
+        node.setmocktime(1333333338)
+        tx2 = CTransaction()
+        tx2.nVersion = 2
+        tx2.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(txid, 16), i),
+                scriptSig=CScript([redeem_script]),
+                nSequence=0xFFFFFFF0 + i,
+            )
+            for i, redeem_script in enumerate(send_redeem_scripts)
+        ]
+        tx2.vout = [CTxOut(coinvalue - 20000, send_scripts[0])]
+        tx2.nLockTime = 12
+
+        # Submit tx to mempool
+        txid2 = node.sendrawtransaction(tx2.serialize().hex())
+
+        proto_tx2 = pb.Tx(
+            txid=bytes.fromhex(txid2)[::-1],
+            version=tx2.nVersion,
+            inputs=[
+                pb.TxInput(
+                    prev_out=pb.OutPoint(txid=bytes.fromhex(txid)[::-1], out_idx=i),
+                    input_script=bytes(tx2.vin[i].scriptSig),
+                    output_script=bytes(script),
+                    value=value,
+                    sequence_no=0xFFFFFFF0 + i,
+                )
+                for i, (value, script) in enumerate(zip(send_values, send_scripts))
+            ],
+            outputs=[
+                pb.TxOutput(
+                    value=tx2.vout[0].nValue,
+                    output_script=bytes(tx2.vout[0].scriptPubKey),
+                )
+            ],
+            lock_time=12,
+            block=None,
+            time_first_seen=1333333338,
+            size=len(tx2.serialize()),
+            is_coinbase=False,
+        )
+
+        assert_equal(chronik.tx(txid2).ok(), proto_tx2)
+
+        # Mine tx
+        tx2blockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        # Invalidate block
+        node.invalidateblock(tx2blockhash)
+
+        # Tx back in mempool
+        assert_equal(chronik.tx(txid2).ok(), proto_tx2)
+
+        # Mine conflicting tx
+        conflict_tx = CTransaction(tx2)
+        conflict_tx.nLockTime = 13
+        block = create_block(
+            int(txblockhash, 16), create_coinbase(103, b"\x03" * 33), 1333333500
+        )
+        block.vtx += [conflict_tx]
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        assert_equal(
+            chronik.tx(txid2).err(404).msg,
+            f"404: Transaction {txid2} not found in the index",
+        )
+        proto_tx2.txid = bytes.fromhex(conflict_tx.hash)[::-1]
+        proto_tx2.lock_time = 13
+        proto_tx2.time_first_seen = 0
+        proto_tx2.block.CopyFrom(
+            pb.BlockMetadata(
+                hash=bytes.fromhex(block.hash)[::-1],
+                height=103,
+                timestamp=1333333500,
+            )
+        )
+
+        assert_equal(chronik.tx(conflict_tx.hash).ok(), proto_tx2)
+
+
+if __name__ == "__main__":
+    ChronikTxTest().main()
diff --git a/test/functional/chronik_tx_removal_order.py b/test/functional/chronik_tx_removal_order.py
new file mode 100644
index 000000000..955c2ab52
--- /dev/null
+++ b/test/functional/chronik_tx_removal_order.py
@@ -0,0 +1,97 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test whether txs are removed in the right order when disconnecting blocks.
+
+When disconnecting a block, the node first removes all txs from the mempool and
+then adds them back in.
+
+Chronik depends on the removal to happen in reverse-topological order (i.e.
+children first), and the insertion to happen in topological order (i.e. parents
+first).
+
+Otherwise, it might remove UTXOs from the index before they're added, crashing
+Chronik.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal
+
+
+class ChronikTxRemovalOrder(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+
+        mocktime = 1300000000
+        node.setmocktime(mocktime)
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        self.generate(node, 100)
+
+        coinvalue = 5000000000
+
+        # Add chain of 10 txs all dependent on each other to the mempool
+        next_value = coinvalue
+        next_txid = cointx
+        for _ in range(10):
+            next_value -= 1000
+            tx = CTransaction()
+            tx.vin = [
+                CTxIn(
+                    outpoint=COutPoint(int(next_txid, 16), 0),
+                    scriptSig=SCRIPTSIG_OP_TRUE,
+                )
+            ]
+            tx.vout = [CTxOut(next_value, P2SH_OP_TRUE)]
+            pad_tx(tx)
+            next_txid = node.sendrawtransaction(tx.serialize().hex())
+
+        # Mine those txs
+        self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)
+
+        # Add a chain of 10 txs dependent on the mined txs
+        for _ in range(10):
+            next_value -= 1000
+            tx = CTransaction()
+            tx.vin = [
+                CTxIn(
+                    outpoint=COutPoint(int(next_txid, 16), 0),
+                    scriptSig=SCRIPTSIG_OP_TRUE,
+                )
+            ]
+            tx.vout = [CTxOut(next_value, P2SH_OP_TRUE)]
+            pad_tx(tx)
+            next_txid = node.sendrawtransaction(tx.serialize().hex())
+
+        assert_equal(len(node.getrawmempool()), 10)
+
+        # If we park the block now, it should correctly move all txs back to the
+        # mempool. Note: This first removes all 10 tx from the mempool and then
+        # adds in the 20.
+        node.parkblock(node.getbestblockhash())
+        assert_equal(len(node.getrawmempool()), 20)
+
+
+if __name__ == "__main__":
+    ChronikTxRemovalOrder().main()
diff --git a/test/functional/chronik_ws.py b/test/functional/chronik_ws.py
new file mode 100644
index 000000000..d08882fa8
--- /dev/null
+++ b/test/functional/chronik_ws.py
@@ -0,0 +1,114 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test whether Chronik sends WebSocket messages correctly."""
+
+from test_framework.avatools import can_find_inv_in_poll, get_ava_p2p_interface
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, chronik_sub_to_blocks
+
+QUORUM_NODE_COUNT = 16
+
+
+class ChronikWsTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [
+            [
+                "-avaproofstakeutxodustthreshold=1000000",
+                "-avaproofstakeutxoconfirmations=1",
+                "-avacooldown=0",
+                "-avaminquorumstake=0",
+                "-avaminavaproofsnodecount=0",
+                "-chronik",
+                "-whitelist=noban@127.0.0.1",
+            ],
+        ]
+        self.supports_cli = False
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        # Build a fake quorum of nodes.
+        def get_quorum():
+            return [
+                get_ava_p2p_interface(self, node) for _ in range(0, QUORUM_NODE_COUNT)
+            ]
+
+        def has_finalized_tip(tip_expected):
+            hash_tip_final = int(tip_expected, 16)
+            can_find_inv_in_poll(quorum, hash_tip_final)
+            return node.isfinalblock(tip_expected)
+
+        # Connect, but don't subscribe yet
+        ws = chronik.ws()
+
+        # Pick one node from the quorum for polling.
+        # ws will not receive msgs because it's not subscribed to blocks yet.
+        quorum = get_quorum()
+
+        assert node.getavalancheinfo()["ready_to_poll"] is True
+
+        tip = node.getbestblockhash()
+        self.wait_until(lambda: has_finalized_tip(tip))
+
+        # Make sure chronik has synced
+        node.syncwithvalidationinterfacequeue()
+
+        # Now subscribe to blocks, we'll get block updates from now on
+        chronik_sub_to_blocks(ws, node)
+
+        # Mine block
+        tip = self.generate(node, 1)[-1]
+        height = node.getblockcount()
+
+        from test_framework.chronik.client import pb
+
+        # We get a CONNECTED msg
+        assert_equal(
+            ws.recv(),
+            pb.WsMsg(
+                block=pb.MsgBlock(
+                    msg_type=pb.BLK_CONNECTED,
+                    block_hash=bytes.fromhex(tip)[::-1],
+                    block_height=height,
+                )
+            ),
+        )
+
+        # After we wait, we get a FINALIZED msg
+        self.wait_until(lambda: has_finalized_tip(tip))
+        assert_equal(
+            ws.recv(),
+            pb.WsMsg(
+                block=pb.MsgBlock(
+                    msg_type=pb.BLK_FINALIZED,
+                    block_hash=bytes.fromhex(tip)[::-1],
+                    block_height=height,
+                )
+            ),
+        )
+
+        # When we invalidate, we get a DISCONNECTED msg
+        node.invalidateblock(tip)
+        assert_equal(
+            ws.recv(),
+            pb.WsMsg(
+                block=pb.MsgBlock(
+                    msg_type=pb.BLK_DISCONNECTED,
+                    block_hash=bytes.fromhex(tip)[::-1],
+                    block_height=height,
+                )
+            ),
+        )
+
+        ws.close()
+
+
+if __name__ == "__main__":
+    ChronikWsTest().main()
diff --git a/test/functional/chronik_ws_ordering.py b/test/functional/chronik_ws_ordering.py
new file mode 100644
index 000000000..00123a03a
--- /dev/null
+++ b/test/functional/chronik_ws_ordering.py
@@ -0,0 +1,243 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test Chronik whether WS are emitted in deterministic order.
+"""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    P2SH_OP_TRUE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.avatools import AvaP2PInterface, can_find_inv_in_poll
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_CHECKSIG, CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal, chronik_sub_script, chronik_sub_to_blocks
+
+QUORUM_NODE_COUNT = 16
+
+
+class ChronikWsOrdering(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [
+            [
+                "-chronik",
+                "-avaproofstakeutxodustthreshold=1000000",
+                "-avaproofstakeutxoconfirmations=1",
+                "-avacooldown=0",
+                "-avaminquorumstake=0",
+                "-avaminavaproofsnodecount=0",
+                "-persistavapeers=0",
+                "-acceptnonstdtxn=1",
+            ]
+        ]
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        from test_framework.chronik.client import pb
+
+        node = self.nodes[0]
+        node.add_p2p_connection(P2PDataStore())
+        chronik = node.get_chronik_client()
+
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointxid = coinblock["tx"][0]
+
+        self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)
+
+        coinvalue = 5000000000
+        balance = coinvalue
+        current_txid = cointxid
+
+        def send_to_script(script) -> str:
+            nonlocal balance, current_txid
+            balance -= 2000
+            tx = CTransaction()
+            tx.vin = [
+                CTxIn(
+                    outpoint=COutPoint(int(current_txid, 16), 0),
+                    scriptSig=SCRIPTSIG_OP_TRUE,
+                )
+            ]
+            tx.vout = [
+                CTxOut(balance, P2SH_OP_TRUE),
+                CTxOut(1000, script),
+            ]
+            pad_tx(tx)
+            current_txid = node.sendrawtransaction(tx.serialize().hex())
+            return current_txid
+
+        def ws_tx_msg(txid: str, msg_type):
+            return pb.WsMsg(
+                tx=pb.MsgTx(
+                    msg_type=msg_type,
+                    txid=bytes.fromhex(txid)[::-1],
+                )
+            )
+
+        def ws_block_msg(block_hash: str, block_height: int, msg_type):
+            return pb.WsMsg(
+                block=pb.MsgBlock(
+                    msg_type=msg_type,
+                    block_hash=bytes.fromhex(block_hash)[::-1],
+                    block_height=block_height,
+                )
+            )
+
+        ifp_hash = "d37c4c809fe9840e7bfa77b86bd47163f6fb6c60"
+        # 1 P2PKH script, just the IFP address
+        p2pkh_script = CScript(bytes.fromhex(f"76a914{ifp_hash}88ac"))
+        # 16 P2SH scripts, 0000...000i for i = 0, ... 14, and IFP address hash
+        p2sh_hashes = []
+        for i in range(15):
+            p2sh_hashes.append(i.to_bytes(20, "big").hex())
+        p2sh_hashes.append(ifp_hash)
+        p2sh_scripts = [
+            (CScript(bytes.fromhex(f"a914{p2sh_hash}87"))) for p2sh_hash in p2sh_hashes
+        ]
+        # 1 P2PK script
+        pubkey = bytes.fromhex(
+            "047fa64f6874fb7213776b24c40bc915451b57ef7f17ad7b982561f99f7cdc7010d141b856a092ee169c5405323895e1962c6b0d7c101120d360164c9e4b3997bd"
+        )
+        p2pk_script = CScript([pubkey, OP_CHECKSIG])
+        # 1 non-standard script
+        other_script = CScript(bytes.fromhex("deadbeef"))
+
+        # Build a fake Avalanche quorum of nodes.
+        def get_quorum():
+            return [
+                node.add_p2p_connection(AvaP2PInterface(self, node))
+                for _ in range(0, QUORUM_NODE_COUNT)
+            ]
+
+        # Pick one node from the quorum for polling.
+        quorum = get_quorum()
+
+        def is_quorum_established():
+            return node.getavalancheinfo()["ready_to_poll"] is True
+
+        def is_finalblock(blockhash):
+            can_find_inv_in_poll(quorum, int(blockhash, 16))
+            return node.isfinalblock(blockhash)
+
+        self.wait_until(is_quorum_established)
+        tip = node.getbestblockhash()
+        self.wait_until(lambda: is_finalblock(tip))
+
+        # Subscribe to all scripts in the test, and to blocks
+        ws = chronik.ws(timeout=240)
+        chronik_sub_script(ws, node, "p2pkh", bytes.fromhex(ifp_hash))
+        for p2sh_hash in p2sh_hashes:
+            chronik_sub_script(ws, node, "p2sh", bytes.fromhex(p2sh_hash))
+        chronik_sub_script(ws, node, "p2pk", pubkey)
+        chronik_sub_script(ws, node, "other", bytes(other_script))
+        chronik_sub_to_blocks(ws, node)
+
+        # Mine block, which will be finalized
+        finalized_blockhash = self.generatetoaddress(
+            node, 1, ADDRESS_ECREG_UNSPENDABLE
+        )[0]
+        cb_txid = node.getblock(finalized_blockhash)["tx"][0]
+        assert not node.isfinalblock(finalized_blockhash)
+        assert not node.isfinaltransaction(cb_txid, finalized_blockhash)
+        finalized_height = node.getblock(finalized_blockhash, 1)["height"]
+
+        assert_equal(
+            ws.recv(),
+            ws_block_msg(finalized_blockhash, finalized_height, pb.BLK_CONNECTED),
+        )
+
+        with node.assert_debug_log(
+            [f"Avalanche finalized block {finalized_blockhash}"]
+        ):
+            self.wait_until(lambda: is_finalblock(finalized_blockhash))
+
+        assert_equal(
+            ws.recv(),
+            ws_block_msg(finalized_blockhash, finalized_height, pb.BLK_FINALIZED),
+        )
+
+        assert node.isfinaltransaction(cb_txid, finalized_blockhash)
+
+        # Send 1 tx to p2pkh
+        p2pkh_txid = send_to_script(p2pkh_script)
+        assert_equal(ws.recv(), ws_tx_msg(p2pkh_txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Send 240 txs to the p2sh scripts, 15 to each script
+        p2sh_txids = []
+        for p2sh_script in p2sh_scripts:
+            for i in range(15):
+                p2sh_txid = send_to_script(p2sh_script)
+                p2sh_txids.append(p2sh_txid)
+                assert_equal(ws.recv(), ws_tx_msg(p2sh_txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Send 1 tx to p2pk
+        p2pk_txid = send_to_script(p2pk_script)
+        assert_equal(ws.recv(), ws_tx_msg(p2pk_txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Send 1 tx to "other" non-standard script
+        other_txid = send_to_script(other_script)
+        assert_equal(ws.recv(), ws_tx_msg(other_txid, pb.TX_ADDED_TO_MEMPOOL))
+
+        # Mine all txs in a block
+        next_blockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_UNSPENDABLE)[0]
+        assert_equal(node.getblockcount(), finalized_height + 1)
+
+        # BLK_CONNECTED always comes first
+        assert_equal(
+            ws.recv(),
+            ws_block_msg(next_blockhash, finalized_height + 1, pb.BLK_CONNECTED),
+        )
+
+        # Then come the TX_CONFIRMED msgs, but in indeterministic order.
+        # When a block is connected, Chronik is sending TX_CONFIRMED into all kinds of
+        # different broadcast channels, and they are per-script.
+        # Then these txs are sorted into the channels, one by one, in *block order*.
+        # In the WS futures, messages are pulled in from the receiving ends of those
+        # channels, but in *script order* (i.e. Ord of ScriptVariant).
+        # So a WS future may pull in a message for a script while handle_block_connected
+        # is still sending txs, but in a different order.
+        # It's sort-of comparable to a mailman sorting mail into mailboxes and some
+        # people are opening their mailboxes and taking mail out while the mailman
+        # is still sorting stuff in, changing the order in which the mail would've
+        # been received if they had waited.
+        actual_ws_msgs = [ws.recv() for i in range(len(p2sh_txids) + 3)]
+        actual_ws_msgs = sorted(actual_ws_msgs, key=lambda m: m.tx.txid[::-1])
+
+        expected_ws_txids = sorted([p2pkh_txid, p2pk_txid, other_txid] + p2sh_txids)
+        expected_ws_msgs = [
+            ws_tx_msg(txid, pb.TX_CONFIRMED) for txid in expected_ws_txids
+        ]
+
+        assert_equal(actual_ws_msgs, expected_ws_msgs)
+
+        # Identical for finalization
+        self.wait_until(lambda: is_finalblock(next_blockhash))
+        # BLK_FINALIZED always comes first
+        assert_equal(
+            ws.recv(),
+            ws_block_msg(next_blockhash, finalized_height + 1, pb.BLK_FINALIZED),
+        )
+        # TX_FINALIZED come next
+        actual_ws_msgs = [ws.recv() for i in range(len(p2sh_txids) + 3)]
+        actual_ws_msgs = sorted(actual_ws_msgs, key=lambda m: m.tx.txid[::-1])
+
+        expected_ws_txids = sorted([p2pkh_txid, p2pk_txid, other_txid] + p2sh_txids)
+        expected_ws_msgs = [
+            ws_tx_msg(txid, pb.TX_FINALIZED) for txid in expected_ws_txids
+        ]
+
+
+if __name__ == "__main__":
+    ChronikWsOrdering().main()
diff --git a/test/functional/chronik_ws_ping.py b/test/functional/chronik_ws_ping.py
new file mode 100644
index 000000000..7cbd8683a
--- /dev/null
+++ b/test/functional/chronik_ws_ping.py
@@ -0,0 +1,55 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""
+Test whether Chronik sends regular WebSocket pings to keep connections open.
+"""
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, chronik_sub_to_blocks
+
+
+class ChronikWsPingTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [["-chronik"]]
+        self.supports_cli = False
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+
+        from test_framework.chronik.client import ChronikWs, pb
+
+        class PingChronikWs(ChronikWs):
+            got_ping = False
+
+            def on_ping(self, ws, message):
+                PingChronikWs.got_ping = True
+
+        # Connect and subscribe to blocks.
+        # Disable pinging from the testing framework, otherwise they cancel Chronik's ping timeout.
+        ws = PingChronikWs(chronik, ping_interval=None, ping_timeout=None)
+        chronik_sub_to_blocks(ws, node)
+
+        # Sanity WS check: mine and expect a CONNECTED msg
+        self.generate(node, 1)[-1]
+        assert_equal(ws.recv().block.msg_type, pb.BLK_CONNECTED)
+
+        # Wait for ping while doing nothing. Ping interval is 5s on regtest.
+        # Note that interacting with the WS would reset the ping timer.
+        self.wait_until(lambda: PingChronikWs.got_ping)
+
+        # Another sanity WS check to ensure the connection is actually still open
+        self.generate(node, 1)[-1]
+        assert_equal(ws.recv().block.msg_type, pb.BLK_CONNECTED)
+
+        ws.close()
+
+
+if __name__ == "__main__":
+    ChronikWsPingTest().main()
diff --git a/test/functional/chronik_ws_script.py b/test/functional/chronik_ws_script.py
new file mode 100644
index 000000000..bc2b86073
--- /dev/null
+++ b/test/functional/chronik_ws_script.py
@@ -0,0 +1,234 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test whether Chronik sends WebSocket messages correctly."""
+
+from test_framework.address import (
+    ADDRESS_ECREG_P2SH_OP_TRUE,
+    ADDRESS_ECREG_UNSPENDABLE,
+    SCRIPTSIG_OP_TRUE,
+)
+from test_framework.avatools import can_find_inv_in_poll, get_ava_p2p_interface
+from test_framework.blocktools import (
+    create_block,
+    create_coinbase,
+    make_conform_to_ctor,
+)
+from test_framework.messages import COutPoint, CTransaction, CTxIn, CTxOut
+from test_framework.p2p import P2PDataStore
+from test_framework.script import OP_EQUAL, OP_HASH160, CScript, hash160
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.txtools import pad_tx
+from test_framework.util import assert_equal, chronik_sub_script
+
+QUORUM_NODE_COUNT = 16
+
+
+class ChronikWsScriptTest(BitcoinTestFramework):
+    def set_test_params(self):
+        self.setup_clean_chain = True
+        self.num_nodes = 1
+        self.extra_args = [
+            [
+                "-avaproofstakeutxodustthreshold=1000000",
+                "-avaproofstakeutxoconfirmations=1",
+                "-avacooldown=0",
+                "-avaminquorumstake=0",
+                "-avaminavaproofsnodecount=0",
+                "-chronik",
+                "-whitelist=noban@127.0.0.1",
+            ],
+        ]
+        self.supports_cli = False
+        self.rpc_timeout = 240
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_chronik()
+
+    def run_test(self):
+        node = self.nodes[0]
+        chronik = node.get_chronik_client()
+        node.setmocktime(1300000000)
+        peer = node.add_p2p_connection(P2PDataStore())
+
+        # Make us a coin
+        coinblockhash = self.generatetoaddress(node, 1, ADDRESS_ECREG_P2SH_OP_TRUE)[0]
+        coinblock = node.getblock(coinblockhash)
+        cointx = coinblock["tx"][0]
+
+        # Set up Avalanche
+        def get_quorum():
+            return [
+                get_ava_p2p_interface(self, node) for _ in range(0, QUORUM_NODE_COUNT)
+            ]
+
+        def has_finalized_tip(tip_expected):
+            hash_tip_final = int(tip_expected, 16)
+            can_find_inv_in_poll(quorum, hash_tip_final)
+            return node.isfinalblock(tip_expected)
+
+        quorum = get_quorum()
+
+        assert node.getavalancheinfo()["ready_to_poll"] is True
+
+        tip = self.generatetoaddress(node, 100, ADDRESS_ECREG_UNSPENDABLE)[-1]
+
+        # Tx sending to 4 different scripts
+        coinvalue = 5000000000
+        send_values = [coinvalue - 10000, 1000, 1000, 1000]
+        send_redeem_scripts = [bytes([i + 0x52]) for i in range(len(send_values))]
+        send_script_hashes = [hash160(script) for script in send_redeem_scripts]
+        send_scripts = [
+            CScript([OP_HASH160, script_hash, OP_EQUAL])
+            for script_hash in send_script_hashes
+        ]
+        tx = CTransaction()
+        tx.vin = [
+            CTxIn(outpoint=COutPoint(int(cointx, 16), 0), scriptSig=SCRIPTSIG_OP_TRUE)
+        ]
+        tx.vout = [
+            CTxOut(value, script) for (value, script) in zip(send_values, send_scripts)
+        ]
+
+        # Connect 2 websocket clients
+        ws1 = chronik.ws()
+        ws2 = chronik.ws()
+        # Subscribe to 2 scripts on ws1 and 1 on ws2
+        chronik_sub_script(ws1, node, "p2sh", send_script_hashes[1])
+        chronik_sub_script(ws1, node, "p2sh", send_script_hashes[2])
+        chronik_sub_script(ws2, node, "p2sh", send_script_hashes[2])
+
+        # Send the tx, will send updates to ws1 and ws2
+        txid = node.sendrawtransaction(tx.serialize().hex())
+        self.wait_until(lambda: txid in node.getrawmempool())
+
+        from test_framework.chronik.client import pb
+
+        expected_msg = pb.WsMsg(
+            tx=pb.MsgTx(
+                msg_type=pb.TX_ADDED_TO_MEMPOOL,
+                txid=bytes.fromhex(txid)[::-1],
+            )
+        )
+        assert_equal(ws1.recv(), expected_msg)
+        assert_equal(ws2.recv(), expected_msg)
+
+        # Unsubscribe ws1 from the other script ws2 is subscribed to
+        chronik_sub_script(ws1, node, "p2sh", send_script_hashes[2], is_unsub=True)
+
+        # tx2 is only sent to ws2
+        tx2 = CTransaction()
+        tx2.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(txid, 16), 2),
+                scriptSig=CScript([send_redeem_scripts[2]]),
+            )
+        ]
+        pad_tx(tx2)
+        txid2 = node.sendrawtransaction(tx2.serialize().hex())
+
+        assert_equal(
+            ws2.recv(),
+            pb.WsMsg(
+                tx=pb.MsgTx(
+                    msg_type=pb.TX_ADDED_TO_MEMPOOL,
+                    txid=bytes.fromhex(txid2)[::-1],
+                )
+            ),
+        )
+
+        # tx3 is only sent to ws1
+        tx3 = CTransaction()
+        tx3.vin = [
+            CTxIn(
+                outpoint=COutPoint(int(txid, 16), 1),
+                scriptSig=CScript([send_redeem_scripts[1]]),
+            )
+        ]
+        pad_tx(tx3)
+        txid3 = node.sendrawtransaction(tx3.serialize().hex())
+
+        assert_equal(
+            ws1.recv(),
+            pb.WsMsg(
+                tx=pb.MsgTx(
+                    msg_type=pb.TX_ADDED_TO_MEMPOOL,
+                    txid=bytes.fromhex(txid3)[::-1],
+                )
+            ),
+        )
+
+        # Tweak tx3 to cause a conflict
+        tx3_conflict = CTransaction(tx3)
+        tx3_conflict.nLockTime = 1
+        tx3_conflict.rehash()
+
+        # Mine tx, tx2 and tx3_conflict
+        height = 102
+        block = create_block(
+            int(tip, 16), create_coinbase(height, b"\x03" * 33), 1300000500
+        )
+        block.vtx += [tx, tx2, tx3_conflict]
+        make_conform_to_ctor(block)
+        block.hashMerkleRoot = block.calc_merkle_root()
+        block.solve()
+        peer.send_blocks_and_test([block], node)
+
+        def check_tx_msgs(ws, msg_type, txids):
+            for txid in txids:
+                assert_equal(
+                    ws.recv(),
+                    pb.WsMsg(
+                        tx=pb.MsgTx(
+                            msg_type=msg_type,
+                            txid=bytes.fromhex(txid)[::-1],
+                        )
+                    ),
+                )
+
+        # For ws1, this sends a REMOVED_FROM_MEMPOOL for tx3, and two CONFIRMED
+        check_tx_msgs(ws1, pb.TX_REMOVED_FROM_MEMPOOL, [tx3.hash])
+        check_tx_msgs(ws1, pb.TX_CONFIRMED, sorted([txid, tx3_conflict.hash]))
+
+        # For ws2, this only sends the CONFIRMED msgs
+        check_tx_msgs(ws2, pb.TX_CONFIRMED, sorted([txid, txid2]))
+
+        # Invalidate the block again
+        node.invalidateblock(block.hash)
+
+        # Adds the disconnected block's txs back into the mempool
+        check_tx_msgs(ws1, pb.TX_ADDED_TO_MEMPOOL, [txid, tx3_conflict.hash])
+        check_tx_msgs(ws2, pb.TX_ADDED_TO_MEMPOOL, [txid, txid2])
+
+        # Test Avalanche finalization
+        tip = node.getbestblockhash()
+        self.wait_until(lambda: has_finalized_tip(tip))
+
+        # Mine txs in a block -> sends CONFIRMED
+        tip = self.generate(node, 1)[-1]
+        check_tx_msgs(ws1, pb.TX_CONFIRMED, sorted([txid, tx3_conflict.hash]))
+        check_tx_msgs(ws2, pb.TX_CONFIRMED, sorted([txid, txid2]))
+
+        # Wait for Avalanche finalization of block -> sends TX_FINALIZED
+        self.wait_until(lambda: has_finalized_tip(tip))
+        check_tx_msgs(ws1, pb.TX_FINALIZED, sorted([txid, tx3_conflict.hash]))
+        check_tx_msgs(ws2, pb.TX_FINALIZED, sorted([txid, txid2]))
+
+        # Invalid subscription, payload too short
+        ws1.sub_script("p2pkh", b"abc")
+        # Chronik responds with an error message
+        assert_equal(
+            ws1.recv(),
+            pb.WsMsg(
+                error=pb.Error(
+                    msg="400: Invalid payload for P2PKH: Invalid length, expected 20 bytes but got 3 bytes"
+                ),
+            ),
+        )
+
+        ws1.close()
+        ws2.close()
+
+
+if __name__ == "__main__":
+    ChronikWsScriptTest().main()
diff --git a/test/functional/test_framework/address.py b/test/functional/test_framework/address.py
index 0d1574e80..5438f2ecc 100755
--- a/test/functional/test_framework/address.py
+++ b/test/functional/test_framework/address.py
@@ -6,11 +6,23 @@
 
 import unittest
 
-from .script import hash256, hash160, CScript
+from .script import hash256, hash160, CScript, CScriptOp, OP_TRUE
 from .util import hex_str_to_bytes
 
 from test_framework.util import assert_equal
 
+ADDRESS_ECREG_UNSPENDABLE = "bchreg:qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqha9s37tt"
+ADDRESS_ECREG_UNSPENDABLE_DESCRIPTOR = (
+    "addr(bchreg:qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqha9s37tt)#u6xx93xc"
+)
+SCRIPT_UNSPENDABLE = CScript.fromhex(
+    "76a914000000000000000000000000000000000000000088ac"
+)
+
+# Coins sent to this address can be spent with a scriptSig of just OP_TRUE
+ADDRESS_ECREG_P2SH_OP_TRUE = "bchreg:prdpw30fk4ym6zl6rftfjuw806arpn26fveknc0qmt"
+P2SH_OP_TRUE = CScript.fromhex("a914da1745e9b549bd0bfa1a569971c77eba30cd5a4b87")
+SCRIPTSIG_OP_TRUE = CScriptOp.encode_op_pushdata(CScript([OP_TRUE]))
 
 chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
 
diff --git a/test/functional/test_framework/blocktools.py b/test/functional/test_framework/blocktools.py
index 408c9eaa5..351e1b904 100755
--- a/test/functional/test_framework/blocktools.py
+++ b/test/functional/test_framework/blocktools.py
@@ -30,6 +30,20 @@ from .messages import (
 from .txtools import pad_tx
 from .util import assert_equal, satoshi_round
 
+# Genesis block data (regtest)
+TIME_GENESIS_BLOCK = 1296688602
+GENESIS_BLOCK_HASH = "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206"
+GENESIS_CB_TXID = "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"
+GENESIS_CB_PK = (
+    "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38"
+    "c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"
+)
+GENESIS_CB_SCRIPT_PUBKEY = CScript.fromhex(f"41{GENESIS_CB_PK}ac")
+GENESIS_CB_SCRIPT_SIG = CScript(
+    b"\x04\xff\xff\x00\x1d\x01\x04EThe Times 03/Jan/2009 Chancellor on brink of "
+    b"second bailout for banks"
+)
+
 
 def create_block(hashprev: Union[int, str], coinbase: Optional[CTransaction], nTime: Optional[int] = None,
                  *, txns=None, ctor=True):
diff --git a/test/functional/test_framework/chronik/__init__.py b/test/functional/test_framework/chronik/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/test/functional/test_framework/chronik/alp.py b/test/functional/test_framework/chronik/alp.py
new file mode 100644
index 000000000..884004329
--- /dev/null
+++ b/test/functional/test_framework/chronik/alp.py
@@ -0,0 +1,109 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+from typing import List
+
+from test_framework.messages import CTxOut
+from test_framework.script import OP_RESERVED, OP_RETURN, CScript
+
+# ALP integers are encoded as 48-bit little-endian integers
+ALP_INT_SIZE = 6
+
+
+def alp_opreturn(*sections: bytes) -> CTxOut:
+    return CTxOut(0, CScript([OP_RETURN, OP_RESERVED] + list(sections)))
+
+
+def extend_var_bytes(target: bytearray, b: bytes):
+    target.append(len(b))
+    target.extend(b)
+
+
+def alp_genesis(
+    *,
+    token_ticker: bytes = b"",
+    token_name: bytes = b"",
+    url: bytes = b"",
+    data: bytes = b"",
+    auth_pubkey: bytes = b"",
+    decimals: int = 0,
+    mint_amounts: List[int],
+    num_batons: int,
+) -> bytes:
+    result = bytearray()
+    result.extend(b"SLP2")
+    result.append(0)
+
+    extend_var_bytes(result, b"GENESIS")
+    extend_var_bytes(result, token_ticker)
+    extend_var_bytes(result, token_name)
+    extend_var_bytes(result, url)
+    extend_var_bytes(result, data)
+    extend_var_bytes(result, auth_pubkey)
+
+    result.append(decimals)
+
+    result.append(len(mint_amounts))
+    for amount in mint_amounts:
+        result.extend(amount.to_bytes(ALP_INT_SIZE, "little"))
+
+    result.append(num_batons)
+    return result
+
+
+def alp_mint(
+    token_id: str,
+    mint_amounts: List[int],
+    num_batons: int,
+) -> bytes:
+    result = bytearray()
+    result.extend(b"SLP2")
+    result.append(0)
+
+    extend_var_bytes(result, b"MINT")
+
+    result.extend(bytes.fromhex(token_id)[::-1])
+
+    result.append(len(mint_amounts))
+    for amount in mint_amounts:
+        result.extend(amount.to_bytes(ALP_INT_SIZE, "little"))
+
+    result.append(num_batons)
+
+    return result
+
+
+def alp_send(
+    token_id: str,
+    output_amounts: List[int],
+) -> bytes:
+    result = bytearray()
+    result.extend(b"SLP2")
+    result.append(0)
+
+    extend_var_bytes(result, b"SEND")
+
+    result.extend(bytes.fromhex(token_id)[::-1])
+
+    result.append(len(output_amounts))
+    for amount in output_amounts:
+        result.extend(amount.to_bytes(ALP_INT_SIZE, "little"))
+
+    return result
+
+
+def alp_burn(
+    token_id: str,
+    burn_amount: int,
+) -> bytes:
+    result = bytearray()
+    result.extend(b"SLP2")
+    result.append(0)
+
+    extend_var_bytes(result, b"BURN")
+
+    result.extend(bytes.fromhex(token_id)[::-1])
+    result.extend(burn_amount.to_bytes(ALP_INT_SIZE, "little"))
+
+    return result
diff --git a/test/functional/test_framework/chronik/client.py b/test/functional/test_framework/chronik/client.py
new file mode 100644
index 000000000..0dca6c842
--- /dev/null
+++ b/test/functional/test_framework/chronik/client.py
@@ -0,0 +1,379 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+import http.client
+import threading
+import time
+from typing import List, Optional, Union
+
+import chronik_pb2 as pb
+import websocket
+
+# Timespan when HTTP requests to Chronik time out
+DEFAULT_TIMEOUT = 30
+
+
+class UnexpectedContentType(Exception):
+    pass
+
+
+class ChronikResponse:
+    def __init__(self, response, *, ok_proto=None, error_proto=None) -> None:
+        self.response = response
+        self.status = response.status
+        self.ok_proto = ok_proto
+        self.error_proto = error_proto
+
+    def ok(self):
+        if self.status != 200:
+            raise AssertionError(
+                f"Expected OK response, but got status {self.status}, error: "
+                f"{self.error_proto}"
+            )
+        return self.ok_proto
+
+    def err(self, status: int):
+        if self.status == 200:
+            raise AssertionError(
+                f"Expected error response status {status}, but got OK: {self.ok_proto}"
+            )
+        if self.status != status:
+            raise AssertionError(
+                f"Expected error response status {status}, but got different error "
+                f"status {self.status}, error: {self.error_proto}"
+            )
+        return self.error_proto
+
+
+class ChronikScriptClient:
+    def __init__(
+        self, client: "ChronikClient", script_type: str, script_payload: str
+    ) -> None:
+        self.client = client
+        self.script_type = script_type
+        self.script_payload = script_payload
+
+    def confirmed_txs(self, page=None, page_size=None):
+        query = _page_query_params(page, page_size)
+        return self.client._request_get(
+            f"/script/{self.script_type}/{self.script_payload}/confirmed-txs{query}",
+            pb.TxHistoryPage,
+        )
+
+    def history(self, page=None, page_size=None):
+        query = _page_query_params(page, page_size)
+        return self.client._request_get(
+            f"/script/{self.script_type}/{self.script_payload}/history{query}",
+            pb.TxHistoryPage,
+        )
+
+    def unconfirmed_txs(self):
+        return self.client._request_get(
+            f"/script/{self.script_type}/{self.script_payload}/unconfirmed-txs",
+            pb.TxHistoryPage,
+        )
+
+    def utxos(self):
+        return self.client._request_get(
+            f"/script/{self.script_type}/{self.script_payload}/utxos", pb.ScriptUtxos
+        )
+
+
+class ChronikTokenIdClient:
+    def __init__(self, client: "ChronikClient", token_id: str) -> None:
+        self.client = client
+        self.token_id = token_id
+
+    def confirmed_txs(self, page=None, page_size=None):
+        query = _page_query_params(page, page_size)
+        return self.client._request_get(
+            f"/token-id/{self.token_id}/confirmed-txs{query}",
+            pb.TxHistoryPage,
+        )
+
+    def history(self, page=None, page_size=None):
+        query = _page_query_params(page, page_size)
+        return self.client._request_get(
+            f"/token-id/{self.token_id}/history{query}",
+            pb.TxHistoryPage,
+        )
+
+    def unconfirmed_txs(self):
+        return self.client._request_get(
+            f"/token-id/{self.token_id}/unconfirmed-txs",
+            pb.TxHistoryPage,
+        )
+
+    def utxos(self):
+        return self.client._request_get(f"/token-id/{self.token_id}/utxos", pb.Utxos)
+
+
+class ChronikLokadIdClient:
+    def __init__(self, client: "ChronikClient", lokad_id: str) -> None:
+        self.client = client
+        self.lokad_id = lokad_id
+
+    def confirmed_txs(self, page=None, page_size=None):
+        query = _page_query_params(page, page_size)
+        return self.client._request_get(
+            f"/lokad-id/{self.lokad_id}/confirmed-txs{query}",
+            pb.TxHistoryPage,
+        )
+
+    def history(self, page=None, page_size=None):
+        query = _page_query_params(page, page_size)
+        return self.client._request_get(
+            f"/lokad-id/{self.lokad_id}/history{query}",
+            pb.TxHistoryPage,
+        )
+
+    def unconfirmed_txs(self):
+        return self.client._request_get(
+            f"/lokad-id/{self.lokad_id}/unconfirmed-txs",
+            pb.TxHistoryPage,
+        )
+
+
+class ChronikWs:
+    def __init__(self, client: "ChronikClient", **kwargs) -> None:
+        self.messages: List[pb.WsMsg] = []
+        self.errors: List[Exception] = []
+        self.timeout = kwargs.get("timeout", client.timeout)
+        self.ping_interval = kwargs.get("ping_interval", 10)
+        self.ping_timeout = kwargs.get("ping_timeout", 5)
+        self.is_open = False
+        self.ws_url = (
+            f"{'wss' if client.https else 'ws'}://{client.host}:{client.port}/ws"
+        )
+
+        self.ws = websocket.WebSocketApp(
+            self.ws_url,
+            on_message=self.on_message,
+            on_error=self.on_error,
+            on_open=self.on_open,
+            on_close=self.on_close,
+            on_ping=self.on_ping,
+            on_pong=self.on_pong,
+        )
+
+        self.ws_thread = threading.Thread(
+            target=self.ws.run_forever,
+            kwargs={
+                "ping_interval": self.ping_interval,
+                "ping_timeout": self.ping_timeout,
+                "ping_payload": "Bitcoin ABC functional test framework",
+            },
+        )
+        self.ws_thread.start()
+
+        connect_timeout = time.time() + self.timeout
+        while not self.is_open:
+            if time.time() > connect_timeout:
+                self.close()
+                raise TimeoutError(
+                    f"Connection to chronik websocket {self.ws_url} timed out after {self.timeout}s"
+                )
+            time.sleep(0.05)
+
+    def on_message(self, ws, message):
+        ws_msg = pb.WsMsg()
+        ws_msg.ParseFromString(message)
+        self.messages.append(ws_msg)
+
+    def on_error(self, ws, error: Exception):
+        self.errors.append(error)
+
+    def on_open(self, ws):
+        self.is_open = True
+
+    def on_close(self, ws, close_status_code, close_message):
+        pass
+
+    def on_ping(self, ws, message):
+        pass
+
+    def on_pong(self, ws, message):
+        pass
+
+    def recv(self):
+        recv_timeout = time.time() + self.timeout
+        while len(self.messages) == 0 and len(self.errors) == 0:
+            if time.time() > recv_timeout:
+                raise TimeoutError(
+                    f"No message received from {self.ws_url} after {self.timeout}s"
+                )
+            time.sleep(0.05)
+        if self.errors:
+            # Raise an error if we encountered one
+            raise self.errors.pop(0)
+        return self.messages.pop(0)
+
+    def send_bytes(self, data: bytes) -> None:
+        self.ws.send(data, websocket.ABNF.OPCODE_BINARY)
+
+    def sub_to_blocks(self, *, is_unsub=False) -> None:
+        sub = pb.WsSub(is_unsub=is_unsub, blocks=pb.WsSubBlocks())
+        self.send_bytes(sub.SerializeToString())
+
+    def sub_script(self, script_type: str, payload: bytes, *, is_unsub=False) -> None:
+        sub = pb.WsSub(
+            is_unsub=is_unsub,
+            script=pb.WsSubScript(script_type=script_type, payload=payload),
+        )
+        self.send_bytes(sub.SerializeToString())
+
+    def sub_token_id(self, token_id: str, *, is_unsub=False) -> None:
+        sub = pb.WsSub(
+            is_unsub=is_unsub,
+            token_id=pb.WsSubTokenId(token_id=token_id),
+        )
+        self.send_bytes(sub.SerializeToString())
+
+    def sub_lokad_id(self, lokad_id: bytes, *, is_unsub=False) -> None:
+        sub = pb.WsSub(
+            is_unsub=is_unsub,
+            lokad_id=pb.WsSubLokadId(lokad_id=lokad_id),
+        )
+        self.send_bytes(sub.SerializeToString())
+
+    def close(self):
+        self.ws.close()
+        self.ws_thread.join(self.timeout)
+        if self.errors:
+            # If there's any errors left over, raise the oldest now
+            raise self.errors.pop(0)
+
+
+class ChronikClient:
+    CONTENT_TYPE = "application/x-protobuf"
+
+    def __init__(
+        self, host: str, port: int, https=False, timeout=DEFAULT_TIMEOUT
+    ) -> None:
+        self.host = host
+        self.port = port
+        self.timeout = timeout
+        self.https = https
+
+    def _request_get(self, path: str, pb_type):
+        return self._request("GET", path, None, pb_type)
+
+    def _request(self, method: str, path: str, body: Optional[bytes], pb_type):
+        kwargs = {}
+        if self.timeout is not None:
+            kwargs["timeout"] = self.timeout
+        client = (
+            http.client.HTTPSConnection(self.host, self.port, **kwargs)
+            if self.https
+            else http.client.HTTPConnection(self.host, self.port, **kwargs)
+        )
+        headers = {}
+        if body is not None:
+            headers["Content-Type"] = self.CONTENT_TYPE
+        client.request(method, path, body, headers)
+        response = client.getresponse()
+        content_type = response.getheader("Content-Type")
+        body = response.read()
+
+        if content_type != self.CONTENT_TYPE:
+            raise UnexpectedContentType(
+                f'Unexpected Content-Type "{content_type}" (expected '
+                f'"{self.CONTENT_TYPE}"), body: {repr(body)}'
+            )
+
+        if response.status != 200:
+            proto_error = pb.Error()
+            proto_error.ParseFromString(body)
+            return ChronikResponse(response, error_proto=proto_error)
+
+        ok_proto = pb_type()
+        ok_proto.ParseFromString(body)
+        return ChronikResponse(response, ok_proto=ok_proto)
+
+    def blockchain_info(self) -> ChronikResponse:
+        return self._request_get("/blockchain-info", pb.BlockchainInfo)
+
+    def block(self, hash_or_height: Union[str, int]) -> ChronikResponse:
+        return self._request_get(f"/block/{hash_or_height}", pb.Block)
+
+    def block_txs(
+        self, hash_or_height: Union[str, int], page=None, page_size=None
+    ) -> ChronikResponse:
+        query = _page_query_params(page, page_size)
+        return self._request_get(
+            f"/block-txs/{hash_or_height}{query}", pb.TxHistoryPage
+        )
+
+    def blocks(self, start_height: int, end_height: int) -> ChronikResponse:
+        return self._request_get(f"/blocks/{start_height}/{end_height}", pb.Blocks)
+
+    def chronik_info(self) -> ChronikResponse:
+        return self._request_get("/chronik-info", pb.ChronikInfo)
+
+    def tx(self, txid: str) -> ChronikResponse:
+        return self._request_get(f"/tx/{txid}", pb.Tx)
+
+    def raw_tx(self, txid: str) -> bytes:
+        return self._request_get(f"/raw-tx/{txid}", pb.RawTx)
+
+    def token_info(self, txid: str) -> bytes:
+        return self._request_get(f"/token/{txid}", pb.TokenInfo)
+
+    def validate_tx(self, raw_tx: bytes) -> ChronikResponse:
+        return self._request(
+            "POST", "/validate-tx", pb.RawTx(raw_tx=raw_tx).SerializeToString(), pb.Tx
+        )
+
+    def broadcast_tx(
+        self, raw_tx: bytes, skip_token_checks: bool = False
+    ) -> ChronikResponse:
+        return self._request(
+            "POST",
+            "/broadcast-tx",
+            pb.BroadcastTxRequest(
+                raw_tx=raw_tx, skip_token_checks=skip_token_checks
+            ).SerializeToString(),
+            pb.BroadcastTxResponse,
+        )
+
+    def broadcast_txs(
+        self, raw_txs: List[bytes], skip_token_checks: bool = False
+    ) -> ChronikResponse:
+        return self._request(
+            "POST",
+            "/broadcast-txs",
+            pb.BroadcastTxsRequest(
+                raw_txs=raw_txs, skip_token_checks=skip_token_checks
+            ).SerializeToString(),
+            pb.BroadcastTxsResponse,
+        )
+
+    def script(self, script_type: str, script_payload: str) -> ChronikScriptClient:
+        return ChronikScriptClient(self, script_type, script_payload)
+
+    def token_id(self, token_id: str) -> ChronikTokenIdClient:
+        return ChronikTokenIdClient(self, token_id)
+
+    def lokad_id(self, lokad_id_hex: str) -> ChronikLokadIdClient:
+        return ChronikLokadIdClient(self, lokad_id_hex)
+
+    def pause(self) -> ChronikResponse:
+        return self._request_get("/pause", pb.Empty)
+
+    def resume(self) -> ChronikResponse:
+        return self._request_get("/resume", pb.Empty)
+
+    def ws(self, **kwargs) -> ChronikWs:
+        return ChronikWs(self, **kwargs)
+
+
+def _page_query_params(page=None, page_size=None) -> str:
+    if page is not None and page_size is not None:
+        return f"?page={page}&page_size={page_size}"
+    elif page is not None:
+        return f"?page={page}"
+    elif page_size is not None:
+        return f"?page_size={page_size}"
+    else:
+        return ""
diff --git a/test/functional/test_framework/chronik/slp.py b/test/functional/test_framework/chronik/slp.py
new file mode 100644
index 000000000..c4a2dbb32
--- /dev/null
+++ b/test/functional/test_framework/chronik/slp.py
@@ -0,0 +1,154 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+import unittest
+from typing import List, Optional
+
+from test_framework.script import OP_RETURN, CScript
+
+# SLP integers are encoded as 64-bit big-endian integers
+SLP_INT_SIZE = 8
+
+
+class SlpScript(CScript):
+    """
+    SLP requires us to encode Scripts differently than CScript currently does.
+    SLP forbids using any single push-opcodes OP_1NEGATE, OP_0...OP_16, but CScript
+    encodes empty bytestrings b"" and numbers between -1 and 16 using them.
+    Therefore, we add SlpScript, which encodes b"" as b"\x4c\x00", and numbers as
+    if these opcodes didn't exist (e.g. 5 is b"\x01\x05", -1 is b"\x01\x81").
+    """
+
+    @classmethod
+    def _coerce_instance(cls, other):
+        if isinstance(other, (bytes, bytearray, int)):
+            if not other:
+                return b"\x4c\x00"
+        if isinstance(other, int):
+            if other == -1:
+                return bytes([1, 0x81])
+            if 0 < other <= 16:
+                return bytes([1, other])
+        return super()._coerce_instance(other)
+
+
+def slp_genesis(
+    *,
+    token_type: int,
+    token_ticker: bytes = b"",
+    token_name: bytes = b"",
+    token_document_url: bytes = b"",
+    token_document_hash: bytes = b"",
+    mint_baton_vout: Optional[int] = None,
+    mint_vault_scripthash: Optional[int] = None,
+    decimals: int = 0,
+    initial_mint_amount: int = 0,
+) -> SlpScript:
+    return SlpScript(
+        [
+            OP_RETURN,
+            b"SLP\0",
+            bytes([token_type]),
+            b"GENESIS",
+            token_ticker,
+            token_name,
+            token_document_url,
+            token_document_hash,
+            bytes([decimals]),
+            mint_vault_scripthash
+            or (bytes([mint_baton_vout]) if mint_baton_vout else b""),
+            initial_mint_amount.to_bytes(SLP_INT_SIZE, "big"),
+        ]
+    )
+
+
+def slp_mint(
+    *,
+    token_type: int,
+    token_id: str,
+    mint_baton_vout: Optional[int],
+    mint_amount: int,
+) -> SlpScript:
+    return SlpScript(
+        [
+            OP_RETURN,
+            b"SLP\0",
+            bytes([token_type]),
+            b"MINT",
+            bytes.fromhex(token_id),
+            bytes([mint_baton_vout]) if mint_baton_vout else b"",
+            mint_amount.to_bytes(SLP_INT_SIZE, "big"),
+        ]
+    )
+
+
+def slp_mint_vault(
+    *,
+    token_id: str,
+    mint_amounts: List[int],
+) -> SlpScript:
+    return SlpScript(
+        [
+            OP_RETURN,
+            b"SLP\0",
+            b"\x02",
+            b"MINT",
+            bytes.fromhex(token_id),
+        ]
+        + [mint_amount.to_bytes(SLP_INT_SIZE, "big") for mint_amount in mint_amounts]
+    )
+
+
+def slp_send(
+    *,
+    token_type: int,
+    token_id: str,
+    amounts: List[int],
+) -> SlpScript:
+    ops = [
+        OP_RETURN,
+        b"SLP\0",
+        bytes([token_type]),
+        b"SEND",
+        bytes.fromhex(token_id),
+    ]
+    for amount in amounts:
+        ops.append(amount.to_bytes(SLP_INT_SIZE, "big"))
+    return SlpScript(ops)
+
+
+def slp_burn(
+    *,
+    token_type: int,
+    token_id: str,
+    amount: int,
+) -> SlpScript:
+    return SlpScript(
+        [
+            OP_RETURN,
+            b"SLP\0",
+            bytes([token_type]),
+            b"BURN",
+            bytes.fromhex(token_id),
+            amount.to_bytes(SLP_INT_SIZE, "big"),
+        ]
+    )
+
+
+class TestFrameworkSlpScript(unittest.TestCase):
+    def test_slp_script(self):
+        # SlpScript encodes b"" as b"\4c\x00"
+        self.assertEqual(SlpScript([b"abc"]), b"\x03abc")
+        self.assertEqual(SlpScript([b""]), b"\x4c\x00")
+        self.assertEqual(SlpScript([b"abc", b""]), b"\x03abc\x4c\x00")
+        self.assertEqual(SlpScript([0]), b"\x4c\x00")
+        self.assertEqual(SlpScript([-1]), b"\x01\x81")
+        self.assertEqual(SlpScript([12, 0]), b"\x01\x0c\x4c\x00")
+
+        # CScript encodes it as OP_0
+        self.assertEqual(CScript([b""]), b"\x00")
+        self.assertEqual(CScript([0]), b"\x00")
+        self.assertEqual(CScript([-1]), b"\x4f")
+        self.assertEqual(CScript([b"abc", b""]), b"\x03abc\x00")
+        self.assertEqual(CScript([12, 0]), b"\x5c\x00")
diff --git a/test/functional/test_framework/chronik/test_data.py b/test/functional/test_framework/chronik/test_data.py
new file mode 100644
index 000000000..af44a8c13
--- /dev/null
+++ b/test/functional/test_framework/chronik/test_data.py
@@ -0,0 +1,41 @@
+# Copyright (c) 2023 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+from test_framework.blocktools import (
+    GENESIS_BLOCK_HASH,
+    GENESIS_CB_SCRIPT_PUBKEY,
+    GENESIS_CB_SCRIPT_SIG,
+    GENESIS_CB_TXID,
+    TIME_GENESIS_BLOCK,
+)
+from test_framework.chronik.client import pb
+
+
+def genesis_cb_tx():
+    return pb.Tx(
+        txid=bytes.fromhex(GENESIS_CB_TXID)[::-1],
+        version=1,
+        inputs=[
+            pb.TxInput(
+                prev_out=pb.OutPoint(txid=bytes(32), out_idx=0xFFFFFFFF),
+                input_script=bytes(GENESIS_CB_SCRIPT_SIG),
+                sequence_no=0xFFFFFFFF,
+            )
+        ],
+        outputs=[
+            pb.TxOutput(
+                value=5000000000,
+                output_script=bytes(GENESIS_CB_SCRIPT_PUBKEY),
+            )
+        ],
+        lock_time=0,
+        block=pb.BlockMetadata(
+            hash=bytes.fromhex(GENESIS_BLOCK_HASH)[::-1],
+            height=0,
+            timestamp=TIME_GENESIS_BLOCK,
+        ),
+        time_first_seen=0,
+        size=204,
+        is_coinbase=True,
+    )
diff --git a/test/functional/test_framework/chronik/token_tx.py b/test/functional/test_framework/chronik/token_tx.py
new file mode 100644
index 000000000..897ad1d5c
--- /dev/null
+++ b/test/functional/test_framework/chronik/token_tx.py
@@ -0,0 +1,76 @@
+# Copyright (c) 2024 The Bitcoin developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+from test_framework.messages import CTransaction
+from test_framework.util import assert_equal
+
+
+class TokenTx:
+    def __init__(
+        self,
+        *,
+        tx: CTransaction,
+        status=0,
+        entries=[],
+        inputs=[],
+        outputs=[],
+        failed_parsings=[],
+        token_info=None,
+    ):
+        tx.rehash()
+        self.tx = tx
+        self.txid = tx.hash
+        self.status = status
+        self.entries = entries
+        self.inputs = inputs
+        self.outputs = outputs
+        self.failed_parsings = failed_parsings
+        self.token_info = token_info
+
+    def send(self, chronik, error=None):
+        raw_tx = self.tx.serialize()
+        proto_tx = chronik.validate_tx(raw_tx).ok()
+        self.test_tx(proto_tx)
+        request = chronik.broadcast_tx(raw_tx)
+        if error is None:
+            request.ok()
+        else:
+            actual_error = request.err(400)
+            assert_equal(actual_error.msg, error)
+            chronik.broadcast_tx(raw_tx, skip_token_checks=True).ok()
+
+    def test(self, chronik, block_hash=None):
+        proto_tx = chronik.tx(self.txid).ok()
+        self.test_tx(proto_tx, block_hash)
+        if self.token_info is not None:
+            proto_token = chronik.token_info(self.txid).ok()
+            self.test_token_info(proto_token, block_hash)
+        else:
+            chronik.token_info(self.txid).err(404)
+
+    def test_tx(self, proto_tx, block_hash=None):
+        import chronik_pb2 as pb
+
+        assert_equal(list(proto_tx.token_failed_parsings), self.failed_parsings)
+
+        assert_equal(proto_tx.token_status, self.status)
+        assert_equal(list(proto_tx.token_entries), self.entries)
+        assert_equal([tx_input.token for tx_input in proto_tx.inputs], self.inputs)
+        assert_equal([tx_output.token for tx_output in proto_tx.outputs], self.outputs)
+        if block_hash is None:
+            assert_equal(proto_tx.block, pb.BlockMetadata())
+        else:
+            assert_equal(proto_tx.block.hash, bytes.fromhex(block_hash)[::-1])
+        assert_equal(list(proto_tx.token_failed_parsings), self.failed_parsings)
+
+    def test_token_info(self, proto_token, block_hash=None):
+        import chronik_pb2 as pb
+
+        assert_equal(proto_token.token_id, self.token_info.token_id)
+        assert_equal(proto_token.token_type, self.token_info.token_type)
+        assert_equal(proto_token.genesis_info, self.token_info.genesis_info)
+        if block_hash is not None:
+            assert_equal(proto_token.block.hash, bytes.fromhex(block_hash)[::-1])
+        else:
+            assert_equal(proto_token.block, pb.BlockMetadata())
diff --git a/test/functional/test_framework/script.py b/test/functional/test_framework/script.py
index 1299ca845..5bd5c4e89 100755
--- a/test/functional/test_framework/script.py
+++ b/test/functional/test_framework/script.py
@@ -487,7 +487,7 @@ class CScript(bytes):
     __slots__ = ()
 
     @classmethod
-    def __coerce_instance(cls, other):
+    def _coerce_instance(cls, other):
         # Coerce other into bytes
         if isinstance(other, CScriptOp):
             other = bytes([other])
@@ -510,7 +510,7 @@ class CScript(bytes):
     def __add__(self, other):
         # Do the coercion outside of the try block so that errors in it are
         # noticed.
-        other = self.__coerce_instance(other)
+        other = self._coerce_instance(other)
 
         try:
             # bytes.__add__ always returns bytes instances unfortunately
@@ -529,7 +529,7 @@ class CScript(bytes):
         else:
             def coerce_iterable(iterable):
                 for instance in iterable:
-                    yield cls.__coerce_instance(instance)
+                    yield cls._coerce_instance(instance)
             # Annoyingly on both python2 and python3 bytes.join() always
             # returns a bytes instance even when subclassed.
             return super(CScript, cls).__new__(
diff --git a/test/functional/test_framework/test_framework.py b/test/functional/test_framework/test_framework.py
index ab0f93b72..67657c5e1 100755
--- a/test/functional/test_framework/test_framework.py
+++ b/test/functional/test_framework/test_framework.py
@@ -30,6 +30,7 @@ from .util import (
     initialize_datadir,
     MAX_NODES,
     p2p_port,
+    chronik_port,
     PortSeed,
     rpc_port,
     set_node_times,
@@ -172,6 +173,9 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
             config['environment']['BUILDDIR'] + os.path.sep + "qt" + os.pathsep + \
             os.environ['PATH']
 
+        # Add test dir to sys.path (to access generated modules)
+        sys.path.append(os.path.join(config["environment"]["BUILDDIR"], "test"))
+
         # Set up temp directory and start logging
         if self.options.tmpdir:
             self.options.tmpdir = os.path.abspath(self.options.tmpdir)
@@ -343,6 +347,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
                 host=rpchost,
                 rpc_port=rpc_port(i),
                 p2p_port=p2p_port(i),
+                chronik_port=chronik_port(i),
                 timewait=self.rpc_timeout,
                 bitcoind=binary[i],
                 bitcoin_cli=self.options.bitcoincli,
@@ -561,6 +566,7 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
                     host=None,
                     rpc_port=rpc_port(i),
                     p2p_port=p2p_port(i),
+                    chronik_port=chronik_port(i),
                     timewait=self.rpc_timeout,
                     bitcoind=self.options.bitcoind,
                     bitcoin_cli=self.options.bitcoincli,
@@ -663,6 +669,16 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
         if not self.is_cli_compiled():
             raise SkipTest("bitcoin-cli has not been compiled.")
 
+    def skip_if_no_chronik(self):
+        """Skip the running test if Chronik indexer has not been compiled."""
+        if not self.is_chronik_compiled():
+            raise SkipTest("Chronik indexer has not been compiled.")
+
+    def skip_if_no_chronik_plugins(self):
+        """Skip the running test if Chronik indexer plugins have not been compiled."""
+        if not self.is_chronik_plugins_compiled():
+            raise SkipTest("Chronik indexer plugins have not been compiled.")
+
     def is_cli_compiled(self):
         """Checks whether bitcoin-cli was compiled."""
         config = configparser.ConfigParser()
@@ -677,6 +693,14 @@ class BitcoinTestFramework(metaclass=BitcoinTestMetaClass):
 
         return config["components"].getboolean("ENABLE_WALLET")
 
+    def is_chronik_compiled(self):
+        """Checks whether Chronik indexer was compiled."""
+        return self.config["components"].getboolean("ENABLE_CHRONIK")
+
+    def is_chronik_plugins_compiled(self):
+        """Checks whether Chronik indexer plugins were compiled."""
+        return self.config["components"].getboolean("ENABLE_CHRONIK_PLUGINS")
+
     def is_zmq_compiled(self):
         """Checks whether the zmq module was compiled."""
         config = configparser.ConfigParser()
diff --git a/test/functional/test_framework/test_node.py b/test/functional/test_framework/test_node.py
index 107bab110..3fd73a608 100755
--- a/test/functional/test_framework/test_node.py
+++ b/test/functional/test_framework/test_node.py
@@ -58,7 +58,7 @@ class TestNode():
     To make things easier for the test writer, any unrecognised messages will
     be dispatched to the RPC connection."""
 
-    def __init__(self, i, datadir, *, chain, host, rpc_port, p2p_port, timewait, bitcoind,
+    def __init__(self, i, datadir, *, chain, host, rpc_port, p2p_port, chronik_port, timewait, bitcoind,
                  bitcoin_cli, mocktime, coverage_dir, extra_conf=None, extra_args=None, use_cli=False, emulator=None):
         self.index = i
         self.datadir = datadir
@@ -69,6 +69,7 @@ class TestNode():
         self.host = host
         self.rpc_port = rpc_port
         self.p2p_port = p2p_port
+        self.chronik_port = chronik_port
         self.name = "testnode-{}".format(i)
         self.rpc_timeout = timewait
         self.binary = bitcoind
@@ -504,6 +505,21 @@ class TestNode():
             p.peer_disconnect()
         del self.p2ps[:]
 
+    def get_chronik_client(self):
+        """Return a ChronikClient instance that communicates with this node"""
+        # Chronik might not be built-in so let's not import each time this file
+        # is included but only where it's expected to not explode.
+        from .chronik.client import DEFAULT_TIMEOUT, ChronikClient
+
+        # host is always None in practice, we should get rid of it at some
+        # point. In the meantime, let's properly handle the API.
+        host = self.host if self.host is not None else "127.0.0.1"
+        return ChronikClient(
+            host,
+            self.chronik_port,
+            timeout=DEFAULT_TIMEOUT,
+        )
+
 
 class TestNodeCLIAttr:
     def __init__(self, cli, command):
diff --git a/test/functional/test_framework/util.py b/test/functional/test_framework/util.py
index 2d33ba5dd..4bd63fe8e 100755
--- a/test/functional/test_framework/util.py
+++ b/test/functional/test_framework/util.py
@@ -369,12 +369,56 @@ def rpc_port(n):
         (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)
 
 
+def chronik_port(n):
+    port = PORT_MIN + 2 * PORT_RANGE + n + \
+        (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)
+    print('port', port)
+    return port
+
+
 def rpc_url(datadir, chain, host, port):
     rpc_u, rpc_p = get_auth_cookie(datadir, chain)
     if host is None:
         host = '127.0.0.1'
     return "http://{}:{}@{}:{}".format(rpc_u, rpc_p, host, int(port))
 
+
+def chronik_sub_to_blocks(ws, node, *, is_unsub=False) -> None:
+    """Subscribe to block events and make sure the subscription is active before returning"""
+    subscribe_log = "unsubscribe from" if is_unsub else "subscribe to"
+    with node.assert_debug_log([f"WS {subscribe_log} blocks"]):
+        ws.sub_to_blocks(is_unsub=is_unsub)
+
+
+def chronik_sub_script(
+    ws, node, script_type: str, payload: bytes, *, is_unsub=False
+) -> None:
+    """Subscribe to script events and make sure the subscription is active before returning"""
+    subscribe_log = "unsubscribe from" if is_unsub else "subscribe to"
+    with node.assert_debug_log([f"WS {subscribe_log} {script_type}({payload.hex()})"]):
+        ws.sub_script(script_type, payload, is_unsub=is_unsub)
+
+
+def chronik_sub_token_id(ws, node, token_id: str, *, is_unsub=False) -> None:
+    """Subscribe to token events and make sure the subscription is active before returning"""
+    subscribe_log = "unsubscribe from" if is_unsub else "subscribe to"
+    with node.assert_debug_log([f"WS {subscribe_log} token ID {token_id}"]):
+        ws.sub_token_id(token_id, is_unsub=is_unsub)
+
+
+def chronik_sub_lokad_id(ws, node, lokad_id: bytes, *, is_unsub=False) -> None:
+    """Subscribe to LOKAD ID events and make sure the subscription is active before returning"""
+    subscribe_log = "unsubscribe from" if is_unsub else "subscribe to"
+    with node.assert_debug_log([f"WS {subscribe_log} LOKAD ID {lokad_id.hex()}"]):
+        ws.sub_lokad_id(lokad_id, is_unsub=is_unsub)
+
+
+def iter_chunks(lst: list, n: int):
+    """Yield successive n-sized chunks from lst."""
+    for i in range(0, len(lst), n):
+        yield lst[i : i + n]
+
+
 # Node functions
 ################
 
@@ -392,6 +436,7 @@ def initialize_datadir(dirname, n, chain):
             f.write("[{}]\n".format(chain_name_conf_section))
         f.write("port=" + str(p2p_port(n)) + "\n")
         f.write("rpcport=" + str(rpc_port(n)) + "\n")
+        f.write(f"chronikbind=127.0.0.1:{str(chronik_port(n))}\n")
         f.write("server=1\n")
         f.write("keypool=1\n")
         f.write("discover=0\n")
diff --git a/test/functional/test_runner.py b/test/functional/test_runner.py
index 3702fa365..e5c2b1f42 100755
--- a/test/functional/test_runner.py
+++ b/test/functional/test_runner.py
@@ -647,7 +647,7 @@ def check_script_prefixes(all_scripts):
     LEEWAY = 10
 
     good_prefixes_re = re.compile(
-        "(bchn[_-])?(example|feature|interface|mempool|mining|p2p|rpc|wallet|tool|ui)[_-]")
+        "(bchn[_-])?(chronik|example|feature|interface|mempool|mining|p2p|rpc|wallet|tool|ui)[_-]")
     bad_script_names = [
         script for script in all_scripts if good_prefixes_re.match(script) is None]
 
